/**
 *  File:
 *    ui.ycp
 *
 *  Module:
 *    Backup module
 *
 *  Authors:
 *    Ladislav Slezak <lslezak@suse.cz>
 *
 *  $Id$
 *
 *  Yast2 user interface functions - dialogs
 */


{

import "Backup";
import "Wizard";
import "Progress";

include "ui/common_popups.ycp";
include "ui/common_functions.ycp";

include "backup/help_texts.ycp";

textdomain "backup";

/**
 * Dialog for setting archive options
 * @return symbol Symbol for wizard sequencer - pressed button
 */

global define symbol ArchDialog() ``{

    // do not allow manual changes of configuration
    if( Backup::no_interactive ) 
    {
	boolean cont = true;
	
	// no multivolume and does not exists, continue
	if (!Backup::multi_volume && SCR::Read(.target.size, Backup::archive_name) != -1)
	{
	    // For translators %1 is archive file name (e.g. /tmp/backup.tar)
	    cont = UI::YesNoPopup(sformat(_("File %1 already exists.\nDo you wish to overwrite it?"), Backup::archive_name));
	}
	else if (Backup::multi_volume)	// test if some volume part exists
	{
	    // list directory content
	    string dir = substring(Backup::archive_name, 0, findlastof(Backup::archive_name, "/"));
	    string fn = substring(Backup::archive_name, findlastof(Backup::archive_name, "/") + 1);

	    y2debug("dir: %1", dir);
	    y2debug("file: %1", fn);

	    list ls = SCR::Read(.target.dir, dir);

	    boolean matched = false;

	    string conflict_file = "";

	    // check if some volume part exists
	    foreach(`f, ls, ``{
		    if (regexpmatch(f, "\d*_" + fn) == true)
		    {
			if (matched == false)
			{
			    matched = true;
			    conflict_file = f;
			}
		    }
		}
	    );

	    y2debug("found volume part: %1", conflict_file);

	    // display question
	    if (matched == true)
	    {
		// For translators %1 is volume file name (e.g. /tmp/01_backup.tar)
		cont = UI::YesNoPopup(sformat(_("Existing file %1\ncan be part of new volume set and it can be rewritten.\nDo you wish to continue?"), dir + "/" + conflict_file));
	    }
	    else
	    {
		cont = true;
	    }
	}
	
	if( cont ) return `next;
    }

    // dialog header
    Wizard::SetContents(_("Archive settings"),
	`VBox(
	    `VSpacing(0.5),
	    // text entry label
	    `TextEntry(`id(`filename), _("Archive file na&me:")),

	    `VSpacing(0.5),
	    // multi line widget label
	    `MultiLineEdit(`id(`description), _("Archive &description:")),

	    `VSpacing(0.5),
	    // frame label
	    `Frame( _("Archive type"),
		`VBox(
		    `VSpacing(`opt(`hstretch), 0.5),
		    `Left(
			`HBox(
			    `HSpacing(2.0),
			    `ComboBox(`id(`type), `opt(`notify),
				// combo box label
				_("Select archive &type:"),
				// archive type - combo box item
				[ `item(`id(`tgz), _("tar with tar-gzip subarchives")),
				// archive type - combo box item
				  `item(`id(`tbz), _("tar with tar-bzip2 subarchives")),
				// archive type - combo box item
				  `item(`id(`tar), _("tar with tar subarchives")),
				// archive type - combo box item
				  `item(`id(`stgz), _("tar with star-gzip subarchives")),
				// archive type - combo box item
				  `item(`id(`stbz), _("tar with star-bzip2 subarchives")),
				// archive type - combo box item
				  `item(`id(`star), _("tar with star subarchives")),
				// archive type - combo box item
				  `item(`id(`txt), _("only list file names"))
				]
			    ),
			    `HSpacing(3.0),
			    `VBox(
				`VSpacing(1.0),
				// push button label
				`PushButton(`id(`opts), _("&Options..."))
			    )
			)
		    ),
		    `VSpacing(0.5)
		)
	    ),

	    `VSpacing(1.0)
	),
        backup_help_archive_settings(), true, true
    );

    if (Backup::archive_type == nil)
	Backup::archive_type = `tgz;

    // set values
    UI::ChangeWidget(`id(`filename), `Value, Backup::archive_name);
    UI::ChangeWidget(`id(`description), `Value, Backup::description);
    UI::ChangeWidget(`id(`type), `Value, Backup::archive_type);

    boolean cont = false;
    symbol ret = nil;

    if (SCR::Read(.runtime.username) != "root" && root_warning_displayed == false)
    {
	// warning popup message
	UI::WarningPopup(_("You are not logged in as root.
Some files can only be read by the user 'root'.
Not all files will be backed up,
so it will not be possible to restore
the system completely later.

System areas on hard disks can only
be backed up by root.
"));
	root_warning_displayed = true;
    }


    while (!cont)
    {
        ret = UI::UserInput();
        Backup::archive_name = UI::QueryWidget(`id(`filename), `Value);

	if (ret == `type)
	{
	    boolean stat = UI::QueryWidget(`id(`type), `Value) != `txt;

	    UI::ChangeWidget(`id(`opts), `Enabled, stat);
	    UI::ChangeWidget(`id(`description), `Enabled, stat);
	}
	else
	{
	    if (ret == `next)
	    {
		symbol type = UI::QueryWidget(`id(`type), `Value);

		// check if star is installed for star subarchive type
		if (type == `star || type == `stgz || type == `stbz)
		{
		    if (SCR::Read(.target.size, "/usr/bin/star") < 0)
		    {
			// YesNoPopup message text - ask to install 'star' package
			boolean inst = UI::YesNoPopup(_("Package 'star' is required for\nselected archive type.\nDo you want to install it?"));

			if (inst == true)
			{
			    // install star - use require.ycp function
			    include "require.ycp";

			    inst = DoInstallAndRemove(["star"], []);
			}

			// if star is still not installed start new UI cycle
			if (!inst)
			{
			    y2debug("star package wasn't installed");
			    continue;
			}
		    }
		}

		if (size(Backup::archive_name) == 0)
		{
		    // warning popup message
		    UI::WarningPopup(_("An archive file name is required.
Enter the file name to use.
"));
		}
		else if (substring(Backup::archive_name, 0, 1) != "/" || SCR::Read(.target.dir, Backup::archive_name) != nil)
		{
		    // warning popup message
		    UI::WarningPopup(_("Please enter archive file name with\nabsolute path (e.g. /tmp/backup.tar)"));
		}
		else if (!Backup::multi_volume && SCR::Read(.target.size, Backup::archive_name) != -1)
		{
		    // For translators %1 is archive file name (e.g. /tmp/backup.tar)
		    cont = UI::YesNoPopup(sformat(_("File %1 already exists.\nDo you wish to overwrite it?"), Backup::archive_name));
		}
		else if (Backup::multi_volume)	// test if some volume part exists
		{
		    // list directory content
		    string dir = substring(Backup::archive_name, 0, findlastof(Backup::archive_name, "/"));
		    string fn = substring(Backup::archive_name, findlastof(Backup::archive_name, "/") + 1);

		    y2debug("dir: %1", dir);
		    y2debug("file: %1", fn);

		    list ls = SCR::Read(.target.dir, dir);

		    boolean matched = false;

		    string conflict_file = "";

		    // check if some volume part exists
		    foreach(`f, ls, ``{
			    if (regexpmatch(f, "\d*_" + fn) == true)
			    {
				if (matched == false)
				{
				    matched = true;
				    conflict_file = f;
				}
			    }
			}
		    );

		    y2debug("found volume part: %1", conflict_file);

		    // display question
		    if (matched == true)
		    {
			// For translators %1 is volume file name (e.g. /tmp/01_backup.tar)
			cont = UI::YesNoPopup(sformat(_("Existing file %1\ncan be part of new volume set and it can be rewritten.\nDo you wish to continue?"), dir + "/" + conflict_file));
		    }
		    else
		    {
			cont = true;
		    }
		}
		else
		{
		    cont = true;
		}
	    }
	    else if (ret == `abort || ret == `cancel)
	    {
		ret = `abort;
		cont = AbortConfirmation(`changed);
	    }
	    else
	    {
		cont = true;
	    }
	}
    }

    // get values
    Backup::description = UI::QueryWidget(`id(`description), `Value);
    Backup::archive_type = UI::QueryWidget(`id(`type), `Value);

    if (ret == `opts)
    {
	if (contains([`tar, `tgz, `tbz, `stgz, `stbz, `star], Backup::archive_type))
	{
	    ret = `tar_opt;
	}
    }

    return ret;
}


/**
 * Setting multi volume archive options
 * @return symbol Symbol for wizard sequencer - pressed button
 */

global define symbol TarOptionsDialog() ``{

    list description_combo = MediaList2UIList(Backup::media_descriptions);
    // combo box item - user defined volume size of archive
    description_combo = add(description_combo, `item(`id(`user_defined), _("User-defined")));

    list description_combo_units = MediaList2UIList(Backup::units_description);

    // dialog header
    Wizard::SetContents( _("Archive file options"),
	`VBox(
	    `VSpacing(0.5),
	    // frame label
	    `Frame(_("Multivolume archive"),
		`VBox(
		    `VSpacing(`opt(`hstretch), 0.5),
		    // check box label
		    `Left(`CheckBox(`id(`multi_volume), `opt(`notify), _("&Create multivolume archive"), Backup::multi_volume)),
		    `VSpacing(0.5),

		    `HBox(
			`HSpacing(3.5),

			`VBox(
			    // combo box label
			    `Left(`ComboBox(`id(`vol), `opt(`notify), _("&Volume size:"), description_combo)),
			    `VSpacing(0.5),

			    `Left(
				`HBox(
				    // text entry label
				    `TextEntry(`id(`user_size), _("&User-defined size:")),
				    `ComboBox(`id(`user_unit), "", description_combo_units),
				    `HStretch()
				)
			    ),
			    `VSpacing(0.5)
			),
			`HSpacing(1.0)
		    )
		)
	    ),
	    `VSpacing(1.0)
	),
        backup_help_archive_options(), true, true
    );

    // replace 'Next' buton with 'Ok'
    Wizard::ReplaceNextButton(`PushButton(`id(`ok), `opt(`default, `key_F10), OKButtonLabel()));
    UI::SetFocus(`id(`ok));

    // allow only digits in the text entry
    UI::ChangeWidget(`id(`user_size), `ValidChars, "0123456789" );

    SetMultiWidgetsState();

    if (Backup::volume_size == nil)
    {
	Backup::volume_size = `fd144;
    }
    UI::ChangeWidget(`id(`vol), `Value, Backup::volume_size);

    string tmp_size = "";
    if (Backup::user_volume_size != nil)
    {
	tmp_size = Backup::user_volume_size;
    }
    UI::ChangeWidget(`id(`user_size), `Value, tmp_size);

    if (Backup::user_volume_unit == nil)
    {
	Backup::user_volume_unit = `B;
    }
    UI::ChangeWidget(`id(`user_unit), `Value, Backup::user_volume_unit);

    boolean cont = false;
    symbol ret = nil;

    while (!cont)
    {
        ret = UI::UserInput();

	if (ret == `ok)
	{
	    if (UI::QueryWidget(`id(`multi_volume), `Value) == true && UI::QueryWidget(`id(`vol), `Value) == `user_defined &&
		    (tofloat(UI::QueryWidget(`id(`user_size), `Value)) * tofloat(Backup::GetCapacity(Backup::units_description, UI::QueryWidget(`id(`user_unit), `Value))) / 1024.0) < 10.0)
	    {
		// warning popup message
		UI::WarningPopup(_("Volume size must be at least 10240 bytes."));
	    }
	    else
	    {
		cont = true;

		Backup::multi_volume = UI::QueryWidget(`id(`multi_volume), `Value);
		Backup::volume_size = UI::QueryWidget(`id(`vol), `Value);
		Backup::user_volume_size = UI::QueryWidget(`id(`user_size), `Value);
		Backup::user_volume_unit = UI::QueryWidget(`id(`user_unit), `Value);
	    }
	}
	else
	{
	    if (ret == `multi_volume || ret == `vol)
	    {
		SetMultiWidgetsState();
	    }
	    else
	    {
		if (ret == `abort || ret == `cancel)
		{
		    ret = `abort;
		    cont = AbortConfirmation(`changed);
		}
		else
		{
		    cont = true;
		}
	    }
	}
    }

    // Restore 'next' button
    Wizard::RestoreNextButton();

    return ret;
}


/**
 * Dialog for setting backup options
 * @return symbol Symbol for wizard sequencer - pressed button
 */

global define symbol BackupDialog() ``{

    // do not allow manual changes of configuration
    if( Backup::no_interactive ) return `next2;

    // dialog header
    Wizard::SetContents( _("Search settings"),
        `VBox(`VSpacing(0.5),
	    // frame label
	    `Frame( _("Backup options"),
	        `VBox(
		    `VSpacing(0.5),
		    // check box label
                    `Left(`CheckBox(`id(`search), `opt(`notify), _("&Search files that do not belong to any package"))),
		    `VSpacing(0.5),
		    // check box label
                    `Left(`CheckBox(`id(`system), _("Backup &hard disk system areas"))),
		    `VSpacing(0.5),
		    // check box label
		    `Left(`CheckBox(`id(`display), _("Check list of files before &creating archive"))),
		    `VSpacing(0.5)
		)
	    ),

	    `VSpacing(1.0),

	    // frame label
	    `Frame( _("Search options"),
		`VBox(
		    `VSpacing(0.5),
		    // frame label
                    `Left(`CheckBox(`id(`md5_check), _("Check MD&5 sum instead of time or size"))),
		    `VSpacing(0.5)
		)
	    ),


	    `VSpacing(1.0)
	),
        backup_help_backup_setting(), true, true
    );

    // set values
    UI::ChangeWidget(`id(`search), `Value, Backup::search);

    if (Backup::archive_type == `txt)
    {
	UI::ChangeWidget(`id(`system), `Enabled, false);
    }

    UI::ChangeWidget(`id(`system), `Value, Backup::system);
    UI::ChangeWidget(`id(`display), `Value, Backup::display);
    UI::ChangeWidget(`id(`md5_check), `Value, Backup::do_md5_test);

    symbol ret = nil;

    while (ret != `next && ret != `abort && ret != `back)
    {
	ret = UI::UserInput();

	if (ret == `abort || ret == `cancel)
	{
	    ret = `abort;
	    if(!AbortConfirmation(`changed))
	    {
		ret = nil;		// not confirmed, unset ret
	    }
	}
    }

    // get values
    Backup::search = UI::QueryWidget(`id(`search), `Value);
    Backup::system = UI::QueryWidget(`id(`system), `Value);
    Backup::display = UI::QueryWidget(`id(`display), `Value);
    Backup::do_md5_test = UI::QueryWidget(`id(`md5_check), `Value);


    // set next dialog
    if (!Backup::search && ret == `next)
    {
	ret = (Backup::system && Backup::archive_type != `txt) ? `next3 : `next2;
    }

    return ret;
}


/**
 * Dialog for setting excluded directories
 * @return symbol Symbol for wizard sequencer - pressed button
 */

global define symbol ExcludeDialog() ``{

    if (Backup::dir_list == nil)
    {
	Backup::dir_list = AddId(Backup::default_dir);
	if (Backup::dir_list == nil)
	{
	    Backup::dir_list = [];
	}
    }

    // initialize excluded filesystems
    if (Backup::detected_fs == nil)
    {
	// dialog header
	Wizard::SetContents("", `Label(_("Detecting file system types...")), "", false, false);
	Backup::detected_fs = GetMountedFilesystems();
	Backup::ExcludeNodevFS();
    }

    // dialog header
    Wizard::SetContents( _("Exclude from search"),
	`VBox(
	    `VSpacing(1.0),
	    // table label
	    `Left(`Label(_("Directories excluded from search:"))),
	    // table header
	    `Table(`id(`dirs), `header(_("Directory")), Backup::dir_list),

	    `HBox(
		// push button label
                `PushButton(`id(`addnew), `opt(`key_F3), _("A&dd...") ) ,
		// push button label
		`PushButton(`id(`edit), `opt(`key_F4), _("&Edit...") ) ,
		// push button label
		`PushButton(`id(`delete), `opt(`key_F5), _("De&lete") )
	    ),

	    `VSpacing(1.0),
	    // push button label
            `PushButton(`id(`expert), `opt(`key_F7), _("E&xpert...") ),
	    `VSpacing(1.0)
	),
        backup_help_exclude_dir(), true, true
    );


    symbol ret = nil;

    while (ret != `next && ret != `back && ret != `abort && ret != `expert)
    {
	ret = UI::UserInput();

	string curr = UI::QueryWidget(`id(`dirs), `CurrentItem);

	if (curr != nil)
	{
            if (ret == `edit)
	    {
		// popup dialog header
	        map edited = ShowEditDialog(_("&Edit"), curr);

		if (lookup(edited, "clicked", nil) == `ok)
		{
		    string txt = lookup(edited, "text", "");

                    if (txt != curr)
		    {
			if (contains(Backup::dir_list, `item(`id(txt), txt)))
			{
			    // error popup message
			    UI::ErrorPopup(sformat(_("Directory %1 is already in the list."), txt));
			}
			else
			{
			    // refresh dir_list content
			    Backup::dir_list = maplist(`i, Backup::dir_list, ``{
				if (select(select(i, 0, ""), 0, "") == curr)
				{
				    return `item(`id(txt), txt);
				}
				else
				{
				    return i;
				}
			    });

			    UI::ChangeWidget(`id(`dirs), `Items, Backup::dir_list);
			}
		    }
		}
	    }

	    if (ret == `delete)
	    {
		Backup::dir_list = filter(`i, Backup::dir_list, ``{return (select(select(i, 0, []), 0, nil) != curr);});
                UI::ChangeWidget(`id(`dirs), `Items, Backup::dir_list);
	    }
	}

	if (ret == `addnew)
	{
	    // dialog popup header
	    map result = ShowEditDialog(_("&Add new directory"), "");

            if (lookup(result, "clicked", nil) == `ok)
            {
                string new_dir = lookup(result, "text", nil);

                // add new partition only if it's not empty a it isn't already in list
                if (new_dir != "" && new_dir != nil)
		{
		    if (contains(Backup::dir_list, `item(`id(new_dir), new_dir)))
		    {
			// error poup message - %1 is a directory name
			UI::ErrorPopup(sformat(_("Directory %1 is already in the list."), new_dir));
		    }
		    else
		    {
			Backup::dir_list = add(Backup::dir_list, `item(`id(new_dir), new_dir));

			UI::ChangeWidget(`id(`dirs), `Items, Backup::dir_list);
		    }
		}
            }
	}

	if (ret == `abort || ret == `cancel)
	{
	    ret = `abort;
	    if (!AbortConfirmation(`changed))
	    {
		ret = nil;
	    }
	}
    }

    if (!(Backup::system && Backup::archive_type != `txt) && ret == `next)
	ret = `next2;

    return ret;
}


/**
 * Dialog for setting excluded file systems from search
 * @return symbol Symbol for wizard sequencer - pressed button
 */

global define symbol ExcludeFilesystemDialog() ``{

    list fs = GetListWithFlags(Backup::detected_fs, Backup::fs_exclude);

    // multi selection box widget label
    string label_multi = _("&Exclude mounted file systems");

    // dialog header
    Wizard::SetContents( _("Exclude file system from search"),
	`VBox(
	    `VSpacing(1.0),
	    `ReplacePoint(`id(`repl), `MultiSelectionBox(`id(`fss), label_multi, fs)),
	    `HBox(
		`HStretch(),
		// push button label
		`HWeight(2, `PushButton(`id(`sel_all), _("&Select all") )),
		// push button label
		`HWeight(2, `PushButton(`id(`desel_all), _("&Deselect all") )),
		`HStretch()
	    ),
	    `VSpacing(1.0)
	),
        backup_help_exclude_fs(), true, true
    );

    // replace 'Next' buton with 'Ok'
    Wizard::ReplaceNextButton(`PushButton(`id(`ok), `opt(`default, `key_F10), OKButtonLabel()));
    UI::SetFocus(`id(`ok));

    symbol ret = nil;

    while (ret != `ok && ret != `back && ret != `abort)
    {
	ret = UI::UserInput();

	if (ret == `sel_all)
	{
	    fs = AddIdBool(fs, true);
	    UI::ReplaceWidget(`id(`repl), `MultiSelectionBox(`id(`fss), label_multi, fs));
	}
	else
	{
	    if (ret == `desel_all)
	    {
		fs = AddIdBool(fs, false);
		UI::ReplaceWidget(`id(`repl), `MultiSelectionBox(`id(`fss), label_multi, fs));
	    }
	    else
	    {
		if (ret == `abort || ret == `cancel)
		{
		    ret = `abort;
		    if (!AbortConfirmation(`changed))
		    {
			ret = nil;	// not confirmed, uset ret
		    }
		}
	    }
	}
    }


    if (ret == `ok)
    {
	Backup::fs_exclude = UI::QueryWidget(`id(`fss), `SelectedItems);
    }

    // Restore 'next' button
    Wizard::RestoreNextButton();

    return ret;
}


/**
 * System area backup options
 * @return symbol Symbol for wizard sequencer - pressed button
 */

global define symbol SystemBackupDialog() ``{

    if (Backup::detected_ext2 == nil)
    {
	// status message - label
	Wizard::SetContents("", `Label(_("Detecting mounted ext2 file systems...")), "", false, false);
	Backup::detected_ext2 = Ext2Filesystems();
	Backup::ext2_backup = AddIdExt2(Backup::detected_ext2);
    }

    // dialog header
    Wizard::SetContents( _("System area backup"),
	`VBox(
	    `VSpacing(0.5),
	    // frame label
	    `Frame( _("Partition table"),
		`VBox(
		    `VSpacing(0.4),
		    // check box label
		    `CheckBox(`id(`pt), `opt(`hstretch), _("Ba&ck up partition tables"), Backup::backup_pt),
		    `VSpacing(0.4)
		)
	    ),
	    `VSpacing(0.5),

	    // frame label
	    `Frame(_("Ext2 file system critical area backup"),
	        `RadioButtonGroup(`id(`rbg),
	            `VBox(
		        `VSpacing(0.3),
			// radio button label
			`Left(`RadioButton(`id(`none), `opt(`notify), _("N&one"), Backup::backup_none_ext2)),
			`VSpacing(0.3),
			// radio button label
			`Left(`RadioButton(`id(`allmounted), `opt(`notify), _("All &mounted"), Backup::backup_all_ext2)),
			`VSpacing(0.3),
			// radio button label
			`Left(`RadioButton(`id(`selected), `opt(`notify), _("&Selected:"), Backup::backup_selected_ext2)),
			`HBox(
			    `HSpacing(3.0),
			    // table header
			    `Table(`id(`par), `header(_("Ext2 partition"), _("Mount point")), Backup::ext2_backup),
			    `HSpacing(2.0)
			),

			`HBox(
			    // push button label
			    `PushButton(`id(`addnew), _("A&dd...") ) ,
			    // push button label
			    `PushButton(`id(`edit), _("&Edit...") ) ,
			    // push button label
			    `PushButton(`id(`delete), _("De&lete") )
		        ),
		        `VSpacing(0.4)
		    )
	        )
	    ),
	    `VSpacing(1.0)
	),
	backup_help_system_backup(), true, true
    );

    UI::ChangeWidget(`id(`par), `Enabled, Backup::backup_selected_ext2);
    UI::ChangeWidget(`id(`addnew), `Enabled, Backup::backup_selected_ext2);
    UI::ChangeWidget(`id(`edit), `Enabled, Backup::backup_selected_ext2);
    UI::ChangeWidget(`id(`delete), `Enabled, Backup::backup_selected_ext2);


    symbol ret = nil;

    while (ret != `next && ret != `back && ret != `abort)
    {
	ret = UI::UserInput();

	string curr = UI::QueryWidget(`id(`par), `CurrentItem);
	if (curr != nil)
	{

            if (ret == `edit)
	    {
	        map edited = ShowEditDialog("&Edit", curr);

		if (lookup(edited, "clicked", nil) == `ok)
		{
		    string txt = lookup(edited, "text", "");
		    string dir = Ext2MountPoint(txt);

		    if (txt != curr)
		    {
			if (contains(Backup::ext2_backup, `item(`id(txt), txt, dir)))
			{
			    // error popup message, %1 is partition name (e.g. /dev/hda1)
			    UI::ErrorPopup(sformat(_("Partition %1 is already in the list."), txt));
			}
			else
			{
			    // refresh ext2_backup content
			    Backup::ext2_backup = maplist(`i, Backup::ext2_backup, ``{
				if (select(select(i, 0, []), 0, nil) == curr)
				{
				    return `item(`id(txt), txt, dir);
				}
				else
				{
				    return i;
				}
			    });

			    // refresh table content
			    UI::ChangeWidget(`id(`par), `Items, Backup::ext2_backup);

			    y2debug("ext2: %1", Backup::ext2_backup);
			}
		    }
		}
	    }

	    if (ret == `delete)
	    {
		Backup::ext2_backup = filter(`i, Backup::ext2_backup, ``{return (select(select(i, 0, []), 0, nil) != curr);});
		UI::ChangeWidget(`id(`par), `Items, Backup::ext2_backup);
	    }
	}

	if (ret == `addnew)
	{
	    // popup dialog header
	    map result = ShowEditDialog(_("&Add Ext2 partition"), "");

	    if (lookup(result, "clicked", nil) == `ok)
	    {
		integer sz = size(Backup::ext2_backup);
		string new_par = lookup(result, "text", nil);
		string dir = Ext2MountPoint(new_par);

		// add new partition only if it's not empty a it isn't already in list
		if (new_par != "" && new_par != nil)
		{
		    if (contains(Backup::ext2_backup, `item(`id(new_par), new_par, dir)))
		    {
			// error popup message, %1 is partition name (e.g. /dev/hda1)
			UI::ErrorPopup(sformat(_("Partition %1 is already in the list."), new_par));
		    }
		    else
		    {
			Backup::ext2_backup = add(Backup::ext2_backup, `item(`id(new_par), new_par, dir));
			UI::ChangeWidget(`id(`par), `Items, Backup::ext2_backup);

			y2debug("ext2: %1", Backup::ext2_backup);
		    }
		}
	    }
	}


	if (ret == `allmounted || ret == `selected || ret == `none)
	{
	    Backup::backup_all_ext2 = UI::QueryWidget(`id(`allmounted), `Value);
	    Backup::backup_none_ext2 = UI::QueryWidget(`id(`none), `Value);
	    Backup::backup_selected_ext2 = UI::QueryWidget(`id(`selected), `Value);

	    UI::ChangeWidget(`id(`par), `Enabled, Backup::backup_selected_ext2);
	    UI::ChangeWidget(`id(`addnew), `Enabled, Backup::backup_selected_ext2);
	    UI::ChangeWidget(`id(`edit), `Enabled, Backup::backup_selected_ext2);
	    UI::ChangeWidget(`id(`delete), `Enabled, Backup::backup_selected_ext2);
	}

	if (ret == `abort || ret == `cancel)
	{
	    ret = `abort;
	    if (!AbortConfirmation(`changed))
	    {
		ret = nil;	// not confirmed, uset ret
	    }
	}
    }

    Backup::backup_pt = UI::QueryWidget(`id(`pt), `Value);

    return ret;
}


/**
 * Display progress of searching modified files in packages
 * @return symbol Symbol for wizard sequencer - pressed button
 */

global define symbol SearchingModifiedDialog() ``{

    Wizard::ClearContents();

    boolean started = SCR::Execute(.background.run_output, Backup::script_get_files + Backup::get_search_script_parameters());
    list script_out = [ ];

    symbol ret = nil;

    if (!started)
    {
	// error popup message
	UI::ErrorPopup(_("Could not start search script.
Backup will be aborted.
"));
	return `abort;
    }


    integer package_num = 0;
    string actual_package = "";
    list package_files = [ ];
    string actual_instprefixes = "";
    string line = "";
    integer total_packages = 0;

    // output strings from search script
    string id_package = "Package: ";
    string id_file = "Size: ";
    string id_nopackage = "Nopackage:";
    string id_instprefixes = "Installed: ";
    string id_reading_packages = "Reading installed packages";
    string id_packages_num = "Packages: ";
    string id_reading_files = "Reading all files";
    string id_files_read = "Files read";

    boolean search_no_package = false;
    boolean reading_installed_packages = false;

    selected_pkg_num = 0;

    while(SCR::Read(.background.output_open) || (SCR::Read(.background.newlines) > 0))
    {
	script_out = SCR::Read(.background.newout);

	while (size(script_out) > 0)
	{
	    line = select(script_out, 0, nil);		// read line
	    script_out = remove(script_out, 0);		// remove line

	    if (reading_installed_packages)
	    {
		if (substring(line, 0, size(id_packages_num)) == id_packages_num)
		{
		    reading_installed_packages = false;
		    total_packages = tointeger(substring(line, size(id_packages_num)));

		    y2milestone("Number of installed packages: %1", total_packages);
		}
	    }
	    else
	    {
		if (substring(line, 0, size(id_package)) == id_package)
		{
		    // store package's changed files
		    if (size(package_files) > 0)
		    {
			map package_info = $[
			    "changed_files" : package_files,
			    "install_prefixes" : actual_instprefixes
			];

			Backup::backup_files = add(Backup::backup_files, actual_package, package_info);
			package_files = [ ];
			selected_pkg_num = selected_pkg_num + 1;
		    }

		    actual_package = substring(line, size(id_package));
		    package_num = package_num + 1;

		    UI::ChangeWidget(`id(`package), `Value, actual_package);
		    UI::ChangeWidget(`id(`progress), `Value, package_num);

		}
		else
		{
		    if  (substring(line, 0, size(id_file)) == id_file)
		    {
			line = substring(line, size(id_file));

			string size_str = substring(line, 0, findfirstof(line, " "));
			modified_size = modified_size + tointeger(size_str);
			modified_num = modified_num + 1;

			UI::ChangeWidget(`id(`totsize), `Value, sformat("%1", size_text(modified_size)));
			UI::ChangeWidget(`id(`numfiles), `Value, sformat("%1", modified_num));

			string found_file = substring(line, findfirstof(line, " ") + 1);

			// escape newlines in file name
			// double backslashes
			list parts = splitstring(found_file, "\\");
			string escaped = mergestring(parts, "\\\\");

			// change newline to \n
			parts = splitstring(escaped, "\n");
			escaped = mergestring(parts, "\\n");

			// add file to list of found files
			package_files = add(package_files, escaped);
		    }
		    else
		    {
			if (line == id_nopackage)
			{
			    if (size(package_files) > 0)
			    {
				map package_info = $[
				    "changed_files" : package_files,
				    "install_prefixes" : actual_instprefixes
				];

				Backup::backup_files = add(Backup::backup_files, actual_package, package_info);
				package_files = [ ];
				selected_pkg_num = selected_pkg_num + 1;
			    }

			    actual_package = "";		// empty package name
			    search_no_package = true;	// no package part of output

			    y2milestone("Searching files which are not in any package started");

			    break;
			}
			else
			{
			    if (substring(line, 0, size(id_instprefixes)) == id_instprefixes)
			    {
				actual_instprefixes = substring(line, size(id_instprefixes));
			    }
			    else
			    {
				if (line == id_reading_files)
				{
				    // label text
				    Wizard::SetContents("", `Label(_("Reading packages files...")), backup_help_searching_modified(), false, false);
				}
				else
				{
				    if (line == id_reading_packages)
				    {
					y2milestone("Reading installed packages");
					// label text
					Wizard::SetContents("", `Label(_("Reading list of installed packages...")), backup_help_searching_modified(), false, false);
					reading_installed_packages = true;
				    }
				    else
				    {
					if (line == id_files_read)
					{
					    // dialog header
					    Wizard::SetContents( _("Searching for modified files"),
						`Top(
						    `VBox(
							`VSpacing(0.5),
							`Left(
							    `HBox(
								// label text
								`Label(_("Modified files: ")),
								`Label(`id(`numfiles), `opt(`hstretch), sformat("%1", modified_num))
							    )
							),
							`VSpacing(0.5),
							`Left(
							    `HBox(
								// label text
								`Label(_("Total size: ")),
								`Label(`id(`totsize), `opt(`hstretch), size_text(modified_size))
							    )
							),
							`VSpacing(0.5),
							`Left(
							    `HBox(
								// label text
								`Label(_("Searching in package: ")),
								`Label(`id(`package), `opt(`hstretch), "")
							    )
							),
							`VSpacing(3.0),
							`Left(
							    // progress bar label
							    `ProgressBar(`id(`progress), _("Searching..."), total_packages)
							)
						    )
						),
						backup_help_searching_modified(), false, false
					    );

					    y2milestone("Searching in packages started");
					}
					else
					{
					    y2warning("Unknown output from search script: %1", line);
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	}

	if (search_no_package)
	{
	    break;
	}

	ret = waitForUserOrProcess(wait_time, `changed);

	if (ret != nil)
	{
	    return ret;
	}

    }

    if (size (package_files) > 0)
    {
	map package_info = $[
	    "changed_files" : package_files,
	    "install_prefixes" : actual_instprefixes
	];

	Backup::backup_files = add(Backup::backup_files, actual_package, package_info);
	selected_pkg_num = selected_pkg_num + 1;
    }

    y2milestone("All packages verified.");

    if (search_no_package)
    {
	string actual_dir = "/";
	string id_readingall = "Reading all files";
	string id_readall = "Files read";
	string id_dir = "Dir: ";

	// dialog header
	Wizard::SetContents(_("Searching files"),
	    `Top(
		`VBox(
		    `VSpacing(0.5),
		    `Left(
			`HBox(
			    // label text
			    `Label(_("Number of files: ")),
			    `Label(`id(`numfiles), `opt(`hstretch), sformat("%1", nopkg_num))
			)
		    ),
		    `VSpacing(0.5),
		    `Left(
			`HBox(
			    // label text
			    `Label(_("Total size: ")),
			    `Label(`id(`totsize), `opt(`hstretch), size_text(nopkg_size))
			)
		    ),
		    `VSpacing(0.5),
		    `Left(
			`HBox(
			    // label text
			    `Label(_("Searching in directory: ")),
			    `Label(`id(`directory), `opt(`hstretch), "")
			)
		    )
		)
	    ),
	    backup_help_searching_files(), false, false
	);


	while(SCR::Read(.background.output_open) || (SCR::Read(.background.newlines) > 0) || (size(script_out) > 0))
	// test of script_out size is needed, because previous while cycle was interrupted and script could exited with no new output...
	{
	    if (size(script_out) == 0)
	    {
		script_out = SCR::Read(.background.newout);
	    }

	    while (size(script_out) > 0)
	    {
		line = select(script_out, 0, nil);	// read line
		script_out = remove(script_out, 0);	// remove line

		y2debug("Script output:", line);

		if  (substring(line, 0, size(id_file)) == id_file)
		{
		    line = substring(line, size(id_file));

		    string size_str = substring(line, 0, findfirstof(line, " "));
		    nopkg_size = nopkg_size + tointeger(size_str);
		    nopkg_num = nopkg_num + 1;

		    UI::ChangeWidget(`id(`totsize), `Value, sformat("%1", size_text(nopkg_size)));
		    UI::ChangeWidget(`id(`numfiles), `Value, sformat("%1", nopkg_num));

		    string found_file = substring(line, findfirstof(line, " ") + 1);

		    // escape newlines in file name
		    // double backslashes
		    list parts = splitstring(found_file, "\\");
		    string escaped = mergestring(parts, "\\\\");

		    // change newline to \n
		    parts = splitstring(escaped, "\n");
		    escaped = mergestring(parts, "\\n");

		    // add file to list of found files
		    package_files = add(package_files, escaped);
		}
		else
		{
		    if  (substring(line, 0, size(id_dir)) == id_dir)
		    {
			actual_dir = substring(line, size(id_dir));
			UI::ChangeWidget(`id(`directory), `Value, actual_dir);
		    }
		}
	    }

	    ret = waitForUserOrProcess(wait_time, `changed);

	    if (ret != nil)
	    {
		return ret;
	    }
	}

	map package_info = $[
	    "changed_files" : package_files,
	    "install_prefixes" : actual_instprefixes
	];

	Backup::backup_files = add(Backup::backup_files, actual_package, package_info);
    }

    y2milestone("Searching done");


    if (Backup::display && !Backup::no_interactive )
    {
	if (Backup::selected_files == nil)
	{
	    Backup::selected_files = Backup::backup_files;
	}

	return `next;
    }
    else
    {
	// no manual selection, backup all files
	Backup::selected_files = Backup::backup_files;
	
	// skip the files listed in Backup::unselected_files
	if (Backup::unselected_files != nil)
	{
	    // try to find each file in selected files
	    foreach(string file, Backup::unselected_files,
	    ``{
		map new_selected = $[ ];
		foreach(string pak, map val, Backup::selected_files,
		``{
		    list changed_files = lookup(val, "changed_files", [ ]);
		    if( contains( changed_files , file ) ) 
		    {
			changed_files = filter( string v, changed_files, ``(v != file) );
			
			// construct new package description
			val = $[ "changed_files" : changed_files,
			         "install_prefixes" : lookup(val, "install_prefixes", [ ] ) ];
		    }
		    new_selected = add( new_selected, pak, val );
		}
		);
		Backup::selected_files = eval(new_selected);
	    }
	    );
	    y2milestone("Filtered out unselected files according to profile");
	}

	// count number of files
	selected_files_num = 0;

	foreach(string pak, map val, Backup::selected_files,
	    ``{
		selected_files_num = selected_files_num + size(lookup(val, "changed_files", []));
	    }
	);

	return `next2;	// skip file selection dialog
    }
}



/**
 * Display found files, user can select files to backup
 * @return symbol Symbol for wizard sequencer - pressed button
 */

global define symbol FilesDialog() ``{

    // dialog header
    Wizard::SetContents("", `Label(_("Adding files to table...")), "", false, false);

    list table_items = MapToTableItems(nil);

    // dialog header
    Wizard::SetContents( _("File selection"),
	`VBox(
	    `VSpacing(0.5),
	    // label text
	    `Left(`Label(_("Select files to back up:"))),
	    `Table(`id(`table),
		`opt(`notify),
		// table header
		`header(" ", _("File name"), _("Package")),
		table_items
	    ),
	    `HBox(
		// push button label
		`PushButton(`id(`sel_file), _("Select or Deselect &file")),
		// push button label
		`PushButton(`id(`sel_all), _("&Select all")),
		// push button label
		`PushButton(`id(`desel_all), _("&Deselect all"))
	    ),
	    `VSpacing(1.0)
	),
	backup_help_file_selection(), true, true
    );


    symbol ret = nil;

    while (ret != `next && ret != `back && ret != `abort)
    {
	ret = UI::UserInput();

	if (ret == `abort || ret == `cancel)
	{
	    ret = `abort;
	    if (!AbortConfirmation(`changed))
	    {
		ret = nil;	// not confirmed, uset ret
	    }
	    else
	    {
		break;
	    }
	}

	integer current_item  = UI::QueryWidget(`id(`table), `CurrentItem);

	if (ret == `sel_all || ret == `desel_all)
	{
	    table_items = (ret == `sel_all) ? MapToTableItems(true) : MapToTableItems(false);

	    UI::ChangeWidget(`id(`table), `Items, table_items);

	    if (current_item != nil)
	    {
		UI::ChangeWidget(`id(`table), `CurrentItem, current_item);
	    }
	}
	else
	{
	    if (ret == `table || ret == `sel_file)
	    {
		string current_value = select(UI::QueryWidget(`id(`table), `Item(current_item)), 1, nocheckmark);

		if (current_value == checkmark)
		{
		    current_value = nocheckmark;
		}
		else
		{
		    current_value = checkmark;
		}

		UI::ChangeWidget(`id(`table), `Item(current_item, 0), current_value);
	    }
	}
    }

    if (ret == `abort)
    {
	return ret;
    }

    y2debug("Getting selected files...");


// Note: it is required that Table contains files ordered by package!

    Backup::selected_files = $[ ];
    Backup::unselected_files = [ ];
    
    integer num = size(table_items);
    integer idx = 1;

    list actual_package_files = [ ];
    string actual_package_name = nil;
    selected_files_num = 0;
    selected_pkg_num = 0;

    while (idx <= num)
    {
	term table_item = UI::QueryWidget(`id(`table), `Item(idx));
	
    	string file_name = select(table_item, 2, "unknown file");

	if (select(table_item, 1, nocheckmark) == checkmark)
	{
	    string package_name = select(table_item, 3, "unknown package");

	    selected_files_num = selected_files_num + 1;

	    if (actual_package_name == nil)
	    {
		actual_package_name = package_name;
	    }

	    if (package_name != actual_package_name)
	    {
		map package_info = $[
		    "changed_files" : actual_package_files,
		    "install_prefixes" : lookup(lookup(Backup::backup_files, actual_package_name, $[]), "install_prefixes", "(none)")
		];
		
		Backup::selected_files = add(Backup::selected_files, actual_package_name,  package_info);

		actual_package_name = package_name;
		actual_package_files = add([], file_name);
		selected_pkg_num = selected_pkg_num + 1;
	    }
	    else
	    {
		actual_package_files = add(actual_package_files, file_name);
	    }
	}
	else
	{
	    Backup::unselected_files = add( Backup::unselected_files, file_name );
	}

	idx = idx + 1;
    }

    /* add last package info */
    if (actual_package_name != nil)
    {
	map package_info = $[
	    "changed_files" : actual_package_files,
	    "install_prefixes" : lookup(lookup(Backup::backup_files, actual_package_name, $[]), "install_prefixes", "(none)")
	];

	Backup::selected_files = add(Backup::selected_files, actual_package_name, package_info);
    }

    y2debug("Selected files to backup: %1", Backup::selected_files);

    return ret;
}


/**
 * Display progress of creating archive
 * @return symbol Symbol for wizard sequencer - pressed button
 */

global define symbol ArchivingDialog() ``{

    // create Progress bar

    // progress bar stage
    list stages1 = [ _("Store host information") ];
    // progress bar stage
    list stages2 = [ _("Storing host information...") ];

    // number of steps = number of selected files + nuber of selected packages
    //			+ 6 files (comment, hostname, date, files, installed_packages, packages_info)
    //			+ 3 steps (comment, hostname, installed PRMs)
    //			+ 3 stages (storing files, creating package archives, creating big archive)
    integer num_stages = selected_files_num + selected_pkg_num + 12;

    if (Backup::system)
    {
	// progress bar stage
	stages1 = add(stages1, _("Create system area backup"));
	// progress bar stage
	stages2 = add(stages2, _("Creating system area backup ..."));

	if (Backup::backup_pt)
	{
	    num_stages = num_stages + 1;
	}

	num_stages = num_stages + size(Backup::ext2_backup);

	num_stages = num_stages + 1;	// System backup stage
    }

    if (Backup::multi_volume)
    {
	num_stages = num_stages + 1;    // tar prints Volume label if multi volume selected, but only at first volume
    }

    if (Backup::search)
    {
	num_stages = num_stages + 1;	// add NOPACKAGE archive step
    }

    // progress bar stage
    stages1 = add(stages1, _("Create package archives"));
    // progress bar stage
    stages1 = add(stages1, _("Create target archive"));

    // progress bar stage
    stages2 = add(stages2, _("Creating package archives..."));
    // progress bar stage
    stages2 = add(stages2, _("Creating target archive..."));

    // progress bar stage
    stages1 = add(stages1, _("Write autoinstallation profile"));
    // progress bar stage
    stages2 = add(stages1, _("Writing autoinstallation profile..."));

    // progress bar label
    Progress::New(_("Creating archive"), " ", num_stages, stages1, stages2, backup_help_creating_archive());

    y2debug("Number of selected packages: %1, selected files: %2", selected_pkg_num, selected_files_num);

    y2milestone("Storing file names list...");

    // store selected file names to file
    string tmpfile_list = SCR::Read(.target.tmpdir) + "/filelist";

    file_list_stored = SCR::Write(.target.string, tmpfile_list, MapFilesToString());

    if (!file_list_stored)
    {
	y2error("Error writing list of selected files to file %", tmpfile_list);
    }

    y2milestone("File names stored");

    // store comment to file
    string tmpfile_comment = SCR::Read(.target.tmpdir) + "/comment";
    comment_stored = SCR::Write(.target.string, tmpfile_comment, Backup::description);


    y2debug("%1", "Comment stored to file");
    Progress::NextStep();

    if (!comment_stored)
    {
	y2warning("Error writing comment to file %", tmpfile_comment);
    }

    added_files = 0;

    boolean started = SCR::Execute(.background.run_output, sformat("%1 %2", Backup::script_create_archive, Backup::get_archive_script_parameters(tmpfile_list, tmpfile_comment)));

    if (!started)
    {
	// error popup message
	UI::ErrorPopup(_("Could not start archiving script.
Backup will be aborted.
"));
	y2error("%1", "Error starting archiving script");
	return `abort;
    }

    list script_out = [ ];

    string id_hostname = "Storing hostname: ";
    string id_date = "Storing date: ";
    string id_partab = "Storing partition table";
    string id_ptstored = "Stored partition: ";
    string id_ok = "Success";
    string id_failed = "Failed";
    string id_storing_installed_pkgs = "Storing list of installed packages";
    string id_storedpkg = "Packages stored: ";
    string id_ext2 = "Storing ext2 area: ";
    string id_archive = "Creating archive:";
    string id_tar_exit = "/Tar result:";
    string id_new_volume = "/Volume created: ";
    string id_not_readable = "/File not readable: ";
    string id_not_stored = "Error storing partition: ";
    string id_pt_read = "Partition tables info read";
    string id_creating_target = "Creating target archive file...";

    archived_num = 0;
    boolean tar_running = false;

    string id_storing_list = "Storing list";
    string id_list_stored = "File list stored";

    e2image_results = [];
    stored_ptables = [];
    created_archive_files = [];

    string last_out = nil;
    boolean system_stage_changed = false;

    y2milestone("Creating archive...");

    while(SCR::Read(.background.output_open) == true || (SCR::Read(.background.newlines) > 0))
    {
	script_out = SCR::Read(.background.newout);

	while (size(script_out) > 0)
	{
	    string line = select(script_out, 0, nil);	// read line
	    script_out = remove(script_out, 0);		// remove line

	    y2debug("Archive script output: %1", line);

	    if (Backup::archive_type == `txt)
	    {
		if (line == id_storing_list)
		{
		}
		else
		{
		    if (line == id_list_stored)
		    {
			stored_list = true;

			y2debug("List of files stored");
			Progress::NextStep();
		    }
		    else
		    {
			y2warning("Unknown output from archive script: %1", line);
		    }
		}
	    }
	    else
	    {
		if (tar_running)
		{
		    if (substring(line, 0, size(id_tar_exit)) == id_tar_exit)
		    {
			tar_result = tointeger(substring(line, size(id_tar_exit)));
		    }
		    else
		    {
			if (substring(line, 0, size(id_new_volume)) == id_new_volume)
			{
			    string vol_name = substring(line, size(id_new_volume));
			    created_archive_files = add(created_archive_files, vol_name);
			}
			else if (line == id_creating_target)
			{
			    y2debug("Creating target archive");
			    Progress::NextStage();
			}
			else if (substring(line, 0, size(id_not_readable)) == id_not_readable)
			{
			    not_readable_files = add(not_readable_files, substring(line, size(id_not_readable)));
			    y2warning("File %1 can not be read.", substring(line, size(id_not_readable)));
			    Progress::NextStep();
			}
			else
			{
			    if (Backup::multi_volume)
			    {
				if (last_out != line)
				{
				    archived_num = archived_num + 1;
				    Progress::NextStep();
				    last_out = line;
				}
			    }
			    else
			    {
				archived_num = archived_num + 1;
				y2debug("File: %1 added to archive", line);
				Progress::NextStep();
			    }
			}
		    }
		}
		else
		{
		    if (substring(line, 0, size(id_hostname)) == id_hostname)
		    {
			string tmp = substring(line, size(id_hostname));
			hostname_stored = (tmp == id_ok);

			y2debug("Hostaneme stored: %1", hostname_stored);
			Progress::NextStage();
		    }
		    else
		    {
			if (substring(line, 0, size(id_date)) == id_date)
			{
			    string tmp = substring(line, size(id_date));
			    date_stored = (tmp == id_ok);

			    y2debug("Date stored: %1", date_stored);
			    Progress::NextStep();
			}
			else
			{
			    if (substring(line, 0, size(id_partab)) == id_partab)
			    {
				if (!system_stage_changed)
				{
				    Progress::NextStage();
				    system_stage_changed = true;
				}
				else
				{
				    Progress::NextStep();
				}
			    }
			    else
			    {
				if (substring(line, 0, size(id_ptstored)) == id_ptstored)
				{
				    string part_name = substring(line, size(id_ptstored));

				    added_files = added_files + 2;
				    stored_ptables = add(stored_ptables, part_name);
				}
				else
				{
				    if (substring(line, 0, size(id_not_stored)) == id_not_stored)
				    {
					failed_ptables = add(failed_ptables, substring(line, size(id_not_stored)));
				    }
				    else
				    {
					if (substring(line, 0, size(id_ext2)) == id_ext2)
					{
					    if (!system_stage_changed)
					    {
						Progress::NextStage();
						system_stage_changed = true;
					    }
					}
					else
					{
					    if (line == id_archive)
					    {

						tar_running = true;
						y2debug("Creating archive");

						// set next stage if system backup was selected, but no partition table or ext2 image was selected
						if (Backup::system && !system_stage_changed)
						{
						    Progress::NextStage();
						    system_stage_changed = true;
						}

						Progress::NextStage();
					    }
					    else
					    {
						if (line == id_ok || line == id_failed)
						{
						    e2image_results = add(e2image_results, (line == id_ok));
						}
						else
						{
						    if (substring(line, 0, size(id_not_readable)) == id_not_readable)
						    {
							not_readable_files = add(not_readable_files, substring(line, size(id_not_readable)));
							y2warning("File %1 can not be read.", substring(line, size(id_not_readable)));
							Progress::NextStep();
						    }
						    else
						    {
							if (line == id_pt_read)
							{
							    read_ptables_info = true;
							}
							else
							{
							    if (line == id_storing_installed_pkgs)
							    {
							    }
							    else
							    {
								if (substring(line, 0, size(id_storedpkg)) == id_storedpkg)
								{
								    packages_list_stored = (substring(line, size(id_storedpkg)) == id_ok);
								    y2debug("Stored list of installed packages %1", packages_list_stored);
								    Progress::NextStep();
								}
								else
								{
								    y2warning("Unknown output from archive script: %1", line);
								}
							    }
							}
						    }
						}
					    }
					}
				    }
				}
			    }
			}
		    }
		}
	    }


	    ret = waitForUserOrProcess(wait_time, `changed);

	    if (ret != nil)
	    {
		return ret;
	    }
	}

    }

    if (ret == `abort)
    {
	// remove incomplete backup archive file
	SCR::Execute(.target.remove, Backup::archive_name);
    }
    else
    {
	// write autoinstallation profile
	Progress::NextStage();
	profilewritten = Backup::WriteProfile(created_archive_files);
    }

    // remove temporary file list and file with comment
    if (!SCR::Execute(.target.remove, tmpfile_list))
    {
	y2warning("Error removing file: %1", tmpfile_list);
    }

    if (!SCR::Execute(.target.remove, tmpfile_comment))
    {
	y2warning("Error removing file: %1", tmpfile_comment);
    }

    return `next;
}



/**
 * Display backup summary
 * @return symbol Symbol for wizard sequencer - pressed button
 */

global define symbol SummaryDialog() ``{
    string br = "<BR>";
    string p  = "<P>";
    string _p = "</P>";

    string em = "<B>";
    string _em = "</B>";

    string backup_result = "";
    string backup_details = "";

    if (Backup::archive_type == `txt)
    {
	// For translators: %1 is entered archive file name (summary text)
	backup_result = p + (stored_list ? sformat(_("List of files saved to file %1"), Backup::archive_name)
	    // part of summary text
	    // summary text
	    : em + _("Error storing list of files") + _em) + _p;
    }
    else
    {
	// part of summary text
	backup_result = p + _("Found modified files: ") + modified_num + br
	// part of summary text
	    + _("Total size: ") + size_text(modified_size) + _p;

	if (Backup::search)
	{
	    // part of summary text
	    backup_result = backup_result + p + _("Found files not in a package: ") + nopkg_num + br
	    // part of summary text
		+ _("Total size: ") + size_text(nopkg_size) + _p;
	}

	if (Backup::display)
	{
	    // part of summary text
	    backup_result = backup_result + p + _("Selected files to backup: ") + selected_files_num + _p;
	}

	    // part of summary text
	backup_details = p + (hostname_stored ? _("Host name stored successfully") :
	    // part of summary text
	    em + _("Storing host name failed") + _em) + br + (date_stored ? _("Date stored successfully") :
	    // part of summary text
	    em + _("Storing date failed") + _em) + br + (file_list_stored ? _("File list stored successfully") :
	    // part of summary text
	    em + _("Storing file list failed") + _em) + br + (comment_stored ? _("Comment stored successfully") :
	    // part of summary text
	    em + _("Storing comment failed") + _em) + br
	    // part of summary text
	    + (packages_list_stored ? _("List of installed packages stored succesfully") :
	    // part of summary text
	    em + _("Storing list of installed packages failed") + _em) + _p;


	if (size(not_readable_files) > 0 || !hostname_stored || !date_stored || !file_list_stored || !comment_stored || !packages_list_stored)
	{
	    // part of summary text, 'Details' is button label
	    backup_result = backup_result + p + _("Some errors occurred during backup. Press 'Details' for more information.") + _p;
	}


	if (size(not_readable_files) > 0)
	{
	    // part of summary text
	    backup_details = backup_details + br + p + em + _("Errors while creating archive:") + _em + br;

	    foreach(`f, not_readable_files,
		``{
		    // For translators: %1 file name - part of summary text
		    backup_details = backup_details + em + sformat(_("Cannot read file %1"), f) + _em + br;
		}
	    );

	    backup_details = backup_details + _p;
	}

	if (Backup::system)
	{
	    y2debug("Ext2 backup: %1", Backup::ext2_backup);
	    y2debug("Ext2 results: %1", e2image_results);

	    if (Backup::backup_pt)
	    {
		if (!read_ptables_info)
		{
		    // part of summary text
		    backup_details = backup_details + p + em + _("Detecting disk partitions failed") + _em + br;
		}

		foreach(`failed_pt, failed_ptables,
		    ``{
			// For translators: %1 is device name of disk, e.g. hda - part of summary text
			backup_details = backup_details + em + sformat(_("Storing partition table of disk /dev/%1 failed"), failed_pt) + _em + br;
		    }
		);

		foreach(`stored_pt, stored_ptables,
		    ``{
			// For translators: %1 is device name of disk, e.g. hda - part of summary text
			backup_details = backup_details + sformat(_("Storing partition table of disk /dev/%1 was successful"), stored_pt) + br;
		    }
		);

	    }

	    if (size(Backup::ext2_backup) > 0)
	    {
		integer index = 0;

		foreach(`r, e2image_results,
		    ``{
			if (r)
			{
			    backup_details = backup_details
				// For translators: %1 is partition name e.g. /dev/hda1 - part of summary text
				+ sformat(_("Ext2 image of %1 stored successfully"), select(select(select(Backup::ext2_backup, index, nil), 0, nil), 0, "")) + br;

			    added_files = added_files + 1;
			}
			else
			{
			    backup_details = backup_details + em
				// For translators: %1 is partition name e.g. /dev/hda1 - part of summary text
				+ sformat(_("Storing Ext2 image of %1 failed"), select(select(select(Backup::ext2_backup, index, nil), 0, nil), 0, "")) + _em + br;
			}

			index = index + 1;
		    }
		);
	    }

	    backup_details = backup_details + _p;
	}

	if (file_list_stored)
	{
	    added_files = added_files + 1;
	}

	if (hostname_stored)
	{
	    added_files = added_files + 1;
	}

	if (date_stored)
	{
	    added_files = added_files + 1;
	}

	if (comment_stored)
	{
	    added_files = added_files + 1;
	}

	if (packages_list_stored)
	{
	    added_files = added_files +1;
	}

	y2debug("selected_files_num: %1", selected_files_num);
	y2debug("added_files: %1", added_files);
	y2debug("total_files: %1", total_files);

	backup_result = backup_result + _p
	    // part of summary text
	    + br + ((selected_files_num + added_files < total_files) ? em + _("Warning: Some files were not backed up") + _em + br : "");

	string archive_created = "";

	if (!Backup::multi_volume)
	{
	    // For translators: %1 is entered archive file name - part of summary text
	    archive_created = sformat(_("Archive %1 created successfully"), Backup::archive_name);
	}
	else
	{
	    // part of summary text
	    archive_created = _("Archive created successfully");
	}

	// part of summary text - %1 is file name
	string profilesummary = (lookup(profilewritten, "result", false) == true) ? sformat(_("Autoinstallation profile saved to file %1."), lookup(profilewritten, "profile", "")) : (b + _("Autoinstallation profile was not saved.") + _b);

	backup_result = backup_result
	    // part of summary text
	    + ((tar_result == 0) ? archive_created : em + _("Archive creation failed") + _em)
	    + br + profilesummary + br
	    + _p;

	// part of summary text
	backup_details = backup_details + p + _("Total archived files: ") + archived_num + _p;


	if (Backup::multi_volume)
	{
	    if (size(created_archive_files) > 0)
	    {
		// part of summary text
		backup_details = backup_details + p + em + "Created archive volumes:" + _em + br;

		foreach(`f, created_archive_files,
		    ``{
			backup_details = backup_details + f + br;
		    }
		);

		backup_details = backup_details + _p;
	    }
	}
    }

    // dialog header
    Wizard::SetContents( _("Backup summary"),
	`VBox(
	    `VSpacing(0.5),
	    `RichText(backup_result),
	    `VSpacing(0.5),
	    // push button label
	    `HBox(
		`PushButton(`id(`details), `opt(`key_F2), _("&Details...")),
		`PushButton(`id(`profiles), _("&Profiles..."))
	    ),
	    `VSpacing(1.0)
	),
	backup_help_summary(), true, true
    );

    if (Backup::archive_type == `txt)
    {
	UI::ChangeWidget(`id(`details), `Enabled, false);
    }

    Wizard::ReplaceNextButton(`PushButton(`id(`finish), `opt(`default), FinishButtonLabel()));
    UI::SetFocus(`id(`finish));

    symbol ret = UI::UserInput();

    while (ret != `finish && ret != `back && ret != `profiles)
    {
	if (ret == `details)
	{
	    // popup dialog header
	    UI::LongTextPopup(_("Backup summary details:"), `RichText(backup_details), 70, 15);
	}
	else if (ret == `abort || ret == `cancel)
	{
	    ret = `abort;
	    if (AbortConfirmation(`changed))
	    {
		break;
	    }
	    else
	    {
		ret = nil;
	    }
	}

	ret = UI::UserInput();
    }

    Wizard::RestoreNextButton();
    return ret;
}

/**
 * Dialog for setting archive options
 * @return symbol Symbol for wizard sequencer - pressed button
 */

global define symbol SelectProfileDialog() ``{

    Backup::ReadBackupProfiles();
    
    // if there is no stored profile return `next
    if (size(Backup::backup_profiles) == 0)
    {
	return `next;
    }

    Wizard::SetContents(_("Profile Selection"),
	`VBox(
	    `VSpacing(1),
	    `SelectionBox(`id(`profile), _("&Available Profiles:"), Backup::BackupProfileNames()),
	    `VSpacing(1),
	    `Frame(_("Action"),
		`RadioButtonGroup(`id(`rb),
		    `VBox(
			`VSpacing(0.5),
			`Left(`RadioButton(`id(`noprofile), _("&Don't Use Profile"), true)),
			`Left(`RadioButton(`id(`use), _("&Use Profile Without Changes"))),
			`Left(`RadioButton(`id(`edit), _("Allow &Changes Before Use"))),
			`VSpacing(0.5)
		    )
		)
	    ),
	    `VSpacing(1.5)
	),
	profile_selection_help(), true, true
    );
    
    if (Backup::selected_profile != nil)
    {
	// select the original profile in the list
        UI::ChangeWidget( `id(`profile), `CurrentItem, Backup::selected_profile );
	
	if (Backup::no_interactive)
	{
	    UI::ChangeWidget( `id(`rb), `CurrentButton, `use );
	}
	else 
	{
	    UI::ChangeWidget( `id(`rb), `CurrentButton, `edit );
	}
    }
    else
    {
	// select the first profile in the list
        UI::ChangeWidget( `id(`profile), `CurrentItem, select( Backup::BackupProfileNames(), 0, nil ) );
    }

    symbol ret = UI::UserInput();
    
    if( ret == `next )
    {
	symbol profile_use = UI::QueryWidget(`id(`rb), `CurrentButton);
	if( profile_use == `use )
	{
	    // use the settings from profile and proceed without user intervention
	    Backup::RestoreSettingsFromBackupProfile( UI::QueryWidget(`id(`profile), `CurrentItem ) );
	    
	    Backup::no_interactive = true;
	}
	else if( profile_use == `edit )
	{
	    // read the settings for the selected profile and continue setup
	    Backup::RestoreSettingsFromBackupProfile( UI::QueryWidget(`id(`profile), `CurrentItem ) );
	    
	    // interactive configuration
	    Backup::no_interactive = false;
	}
	else
	{
	    // do not use profile at all
	    Backup::RestoreDefaultSettings();

	    // interactive configuration
	    Backup::no_interactive = false;
	}
    }
    
    return ret;
}

// select a profile, where to save the current settings
global define symbol ProfileDialog() ``{

    Wizard::SetContents(_("Profiles"),
	`VBox(
	    `ReplacePoint(`id(`selectionBox), 
	    `SelectionBox(`id(`profile), _("&Available Profiles:"), Backup::BackupProfileNames()  )
	    ),
	    `HBox(
		`PushButton(`id(`add), _("&Save As New...")),
		`PushButton(`id(`replace), _("Re&place")),
		`PushButton(`id(`delete), UI::DeleteButtonLabel())
	    ),
	    `VSpacing(1.5)
	),
	profile_help(), true, true
    );
    
    if (Backup::selected_profile != nil )
    {
	// select the original profile in the list
        UI::ChangeWidget( `id(`profile), `CurrentItem, Backup::selected_profile );
    }
    else
    {
	// select the first profile in the list
        UI::ChangeWidget( `id(`profile), `CurrentItem, select( Backup::BackupProfileNames(), 0, nil ) );
    }

    Wizard::ReplaceNextButton(`PushButton(`id(`ok), `opt(`default), OKButtonLabel()));

    
    symbol ret = nil;
    do
    {
	ret = UI::UserInput();
	
	if( ret == `add )
	{
	    // add a new profile with the current settings
	    
	    // Translators: text of a popup dialog
	    map new_name = ShowEditDialog(_("Enter name for the new profile"), "");

	    if( lookup( new_name, "clicked", nil ) == `ok )
	    {
		Backup::StoreSettingsToBackupProfile( lookup( new_name, "text", "" ) );
		UI::ReplaceWidget( `id(`selectionBox), 
		    `SelectionBox(`id(`profile), _("&Available Profiles:"), Backup::BackupProfileNames() ) );
	    }
	} 
	else if( ret == `replace ) 
	{
	    // replace the selected profile with the current settings
	    Backup::StoreSettingsToBackupProfile( UI::QueryWidget(`id(`profile), `CurrentItem ) );
	}
	else if( ret == `delete )
	{
	    // remove the selected profile
	    Backup::RemoveBackupProfile( UI::QueryWidget(`id(`profile), `CurrentItem ) );
	    UI::ReplaceWidget( `id(`selectionBox), 
		`SelectionBox(`id(`profile), _("&Available Profiles:"), Backup::BackupProfileNames() ) );
	}
    } while( ret != `ok && ret != `cancel && ret != `abort && ret != `back );
    
    if( ret == `ok )
    {
	y2milestone(" *** Storing profiles ***");
	Backup::WriteBackupProfiles();
    }

    Wizard::RestoreNextButton();
    return ret;
}

}

