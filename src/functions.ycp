/**
 *  File:
 *    functions.ycp
 *
 *  Module:
 *    Backup module
 *
 *  Authors:
 *    Ladislav Slezak <lslezak@suse.cz>
 *
 *  $Id$
 *
 *  Functions used by backup module.
 */


{

import "Label";
import "Report";

import "AutoinstClone";
import "Profile";

textdomain "backup";


/**
 * Display abort confirmation dialog
 * @param type Select dialog type, possible values: `changed, `not_changed or `none for none dialog
 * @return boolean False if user select to not abort, true otherwise.
 */

global define boolean AbortConfirmation(symbol type) ``{

    boolean ret = nil;

    // popup dialog header
    string heading = _("Abort confirmation");
    // popup dialog question
    string question = _("Do you really want to abort the backup?");
    string yes = Label::YesButton();	// from common_messages.ycp
    string no = Label::NoButton();

    if (type == `changed)
    {
	ret = Popup::AnyQuestion(heading, question, yes, no, `focus_no);
    }
    else
    {
	if (type == `not_changed)
	{
	    ret = Popup::AnyQuestion(heading, question, yes, no, `focus_yes);
	}
	else
	{
	    if (type == `none)
	    {
		ret = true;
	    }
	    else
	    {
		y2warning("Unknown type of abort confirmation dialog: %1", type);
	    }
	}
    }

    return ret;
}


/**
 * Ask user for some value: display dialog with label, text entry and OK/Cancel buttons.
 * @param label Displayed text above the text entry in the dialog
 * @param value Default text in text entry, for empty text set value to "" or nil
 * @return map Returned map: $[ "text" : string, "clicked" : symbol ]. Value with key text is string entered by user, symbol is `ok or `cancel depending which button was pressed.
 */

global define map ShowEditDialog(string label, string value) ``{

    if (label == nil)
    {
	label = "";
    }

    if (value == nil)
    {
	value = "";
    }

    UI::OpenDialog(
	`VBox(
	    `TextEntry(`id(`te), label, value),
	    `VSpacing(1.0),
	    `HBox(
	        `PushButton(`id(`ok), `opt(`default, `key_F10), Label::OKButton()),
		`PushButton(`id(`cancel), `opt(`key_F9), Label::CancelButton())
	    )
	)
    );

    UI::SetFocus(`id(`te));

    symbol input = UI::UserInput();

    string text = UI::QueryWidget(`id(`te), `Value);
    UI::CloseDialog();

    return $[ "text" : text, "clicked" : input ];
}



/**
 * Wait for output from subprocess or user action. If user press `abort button, then subprocess is terminated.
 * @param wait Delay in miliseconds between user action checks (if no output from subprocess is available)
 * @param abort_question Symbol for AbortConfirmation function - which dialog will be displayed if Abort button is pressed
 * @return symbol Pressed button id or nil if some data is ready from subprocess.
 */

global define symbol waitForUserOrProcess(integer wait, symbol abort_question) ``{
    symbol ret = UI::PollInput();

    if (ret == `abort || ret == `cancel)
    {
	y2warning("Abort pressed");
	ret = `abort;

	if (AbortConfirmation(abort_question))
	{
	    SCR::Execute(.background.kill, nil);
	    return ret;
	}
	else
	{
	    ret = nil;
	}
    }

    while (SCR::Read(.background.newlines) == 0 && SCR::Read(.background.output_open))
    {
	sleep(wait);

	ret = UI::PollInput();

	if (ret == `abort || ret == `cancel)
	{
	    ret = `abort;
	    y2warning("Abort pressed");

	    if (AbortConfirmation(abort_question))
	    {
		SCR::Execute(.background.kill, nil);
		break;
	    }
	    else
	    {
		ret = nil;
	    }
	}
    }

    return ret;
}


/**
 * Returns list of mounted file systems types.
 * @return list List of strings, each mounted file system type is reported only onetimes, list is alphabetically sorted.
 * @example GetMountedFilesystems() -> [ "devpts", "ext2", "nfs", "proc", "reiserfs" ]
 */

global define list GetMountedFilesystems() ``{
    list mounted = SCR::Read(.proc.mounts);
    list result = [ ];

    if (mounted == nil)
    {
	return [];
    }

    foreach(`m, mounted,
	``{
	    string fs = lookup(m, "vfstype", nil);

	    if (fs != nil)
	    {
		result = add(result, fs);
	    }
	}
    );

    return toset(result);
}


/**
 * Returns list of Ext2 mountpoints - actually mounted and from /etc/fstab file
 * @return list List of strings
 * @example Ext2Filesystems() -> [ "/dev/hda1", "/dev/hda4" ]
 */

global define list Ext2Filesystems() ``{
    list mounted = SCR::Read(.proc.mounts);
    list result = [ ];
    list tmp_parts = [];

    if (mounted != nil)
    {
	foreach(`m, mounted,
	    ``{
		string fs = lookup(m, "vfstype", nil);
		string dev = lookup(m, "spec", nil);
		string file = lookup(m, "file", nil);

		if (fs == "ext2" && dev != nil && !contains(tmp_parts, dev))
		{
		    result = add(result, $[ "partition" : dev, "mountpoint" : file ]);
		    tmp_parts = add(tmp_parts, dev);
		}
	    }
	);
    }

    list fstab = SCR::Read(.etc.fstab);

    if (fstab != nil)
    {
	foreach(`f, fstab,
	    ``{
		string fs = lookup(f, "vfstype", nil);
		string dev = lookup(f, "spec", nil);
		string file = lookup(f, "file", nil);

		if (fs == "ext2" && dev != nil && !contains(tmp_parts, dev))
		{
		    result = add(result, $[ "partition" : dev, "mountpoint" : file ]);
		    tmp_parts = add(tmp_parts, dev);
		}
	    }
	);
    }

    return result;
}


/**
 * This function reads two lists: full list and selection list (contains subset of items in full list). Returned list can be used in MultiSelectionBox widget.
 * @return list List of alphabetically sorted strings
 * @param in List of items
 * @param selected List with subset of items from list in.
 * @example GetListWithFlags(["/dev", "/etc"], ["/etc"]) -> [`item (`id ("/dev"), "/dev", false), `item (`id ("/etc"), "/etc", true)]
 */

global define list GetListWithFlags(list in, list selected) ``{

    if (in == nil)
    {
	return [];
    }

    return maplist(`i, in, ``{
	return `item(`id(i), i, (contains(selected, i) ? true : false));
    });
}

/**
 * Set boolean value val to all items in list.
 * @return list List of items
 * @param in Input list of items
 * @param val Requested value
 * @example AddIdBool( [ `item(`id("ext2"), "ext2", true) ], false) ) -> [ `item (`id ("ext2"), "ext2", false) ]
 */

global define list AddIdBool(list in, boolean val) ``{
    if (val == nil)
    {
	val = false;
    }

    if (in == nil)
    {
	return [];
    }

    return maplist(`i, in, ``{
	term tmp_id = nil;
	string tmp_s = nil;

	boolean isterm = is(i,term);

	if (isterm)
	{
	    tmp_id = select(i, 0, nil);
	    tmp_s = select(i, 1, nil);
	}

        return (isterm && tmp_id != nil && tmp_s != nil) ? `item(tmp_id, tmp_s, val) : nil;
    });
}


/**
 * Returns list of items from list of values.
 * @return list List of items
 * @param in Input list of values
 * @example AddId("abc", "123") -> [`item(`id("abc"), "abc"), `item(`id("123"), "123")]
 */

global define list AddId(list in) ``{
    if (in == nil) return [];

    return maplist(`i, in, ``{
	return `item(`id(i), i);
    });
}


/**
 * Returns list of items from list of values.
 * @return list List of items
 * @param in Input list of maps with keys "partition", "mountpoints" and strings as values
 * @example AddId([ $["partition" : "/dev/hda3", "mountpoint" : "/usr"] ]) -> [`item(`id("/dev/hda3"), "/dev/hda3", "/usr")]
 */

global define list AddIdExt2(list in) ``{

    if (in == nil) return [];

    return maplist(`i, in, ``{
	string pt = lookup(i, "partition", nil);
	string mp = lookup(i, "mountpoint", nil);

        return `item(`id(pt), pt, mp);
    });
}

/**
 * Returns string generated from selected files list. String is in format which
 * is accepted by backup_archive.pl script. Used global variables:
 * selected_files, backup_files.
 * @return map map with keys "filelist" (string - list of files), "sel_files"
 *	(integer - number of selected files), "sel_packages" (integer: number
 *	of selected packages).
 * @see <a href="../backup_specification.html">Backup module specification</a>
 */

global define map MapFilesToString() ``{
    string result = "";
    integer num_files = 0;
    integer num_pack = 0;

    if (Backup::selected_files == nil || Backup::backup_files == nil || list_of_installed_packages == nil)
    {
	return "";
    }

    foreach(`pkg, `info, Backup::selected_files,
        ``{
            if (pkg != "")
            {
		string tmp = "Package: " + pkg + "\nInstalled: "
		    + lookup(lookup(Backup::backup_files, pkg, $[]), "install_prefixes", "(none)") + "\n";

		list chfiles = info["changed_files"]:[];
		result = result + tmp + mergestring(chfiles, "\n") + "\n";

		num_files = num_files + size(chfiles);
		num_pack = num_pack + 1;
            }
        }
    );

    list nopkg = lookup(lookup(Backup::selected_files, "", $[ ]), "changed_files", []);

    if (size(nopkg) > 0)
    {
	result = result + "Nopackage:\n" + mergestring(nopkg, "\n") + "\n";

	num_files = num_files + size(nopkg);
	num_pack = num_pack + 1;
    }

    return $[ "filelist" : result, "sel_files" : num_files, "sel_packages" : num_pack ];
}


/**
 * Convert media description list to ComboBox items list
 * @param media Medium descriptions - list of maps with keys (and values): "label" (description string), "symbol" (identification symbol), "capacity" (size of free space on empty medium)
 * @return list Items list for UI widgets
 */

global define list MediaList2UIList(list media) ``{
    list result = [];

    if (media == nil)
    {
	return [];
    }

    foreach(`v, media,
	``{
	    if (is(v, map))
	    {
		symbol i = lookup(v, "symbol", nil);
		string l = lookup(v, "label", nil);

		if (i != nil && l != nil)
		{
		    result = add(result, `item(`id(i), l));
		}
	    }
	}
    );

    return result;
}


/**
 * Set state of depending widgets in Multiple volume options dialog
 * @return void
 */

global define void SetMultiWidgetsState() ``{
    boolean tmp_multi = UI::QueryWidget(`id(`multi_volume), `Value);
    UI::ChangeWidget(`id(`vol), `Enabled, tmp_multi);

    boolean user = (tmp_multi && UI::QueryWidget(`id(`vol), `Value) == `user_defined);
    UI::ChangeWidget(`id(`user_size), `Enabled, user);
    UI::ChangeWidget(`id(`user_unit), `Enabled, user);
}

/**
 * Return mount point for Ext2 partition. This function at first checks if partition is mounted. If yes it returns actual mout point, if no it searches mount point from /etc/fstab file.
 * @param device_name Name of device
 * @return string Mount point of device or nil if device does not exist or there is other file system than Ext2
 * @example Ext2MountPoint("/dev/hda1") -> "/boot"
 */

global define string Ext2MountPoint(string device_name) ``{
    // chack if partition is now mounted
    list mp = SCR::Read(.proc.mounts);
    string result = nil;

    if (mp != nil)
    {
	foreach(`p, mp,
	    ``{
		string d = lookup(p, "file", nil);
		string dev = lookup(p, "spec", nil);
		string fs = lookup(p, "vfstype", nil);

		if (fs == "ext2" && dev == device_name)
		{
		    result = d;
		}
	    }
	);
    }

    // if partition is not mounted then search mount point from fstab
    if (result == nil)
    {
	list fstab = SCR::Read(.etc.fstab);

	if (fstab != nil)
	{
	    foreach(`p, fstab,
		``{
		    string d = lookup(p, "file", nil);
		    string dev = lookup(p, "spec", nil);
		    string fs = lookup(p, "vfstype", nil);

		    if (fs == "ext2" && dev == device_name)
		    {
			result = d;
		    }
		}
	    );
	}
    }

    return result;
}


/**
 * Add extension to the file name if it is missing.
 * @param file filname
 * @param extension file extension (with dot)
 * @return string filename with extension
 * @example AddMissingExtension("filename", ".ext") -> "filename.ext"
 * @example AddMissingExtension("filename.tar", ".gz") -> "filename.tar.gz"
 * @example AddMissingExtension("filename.tar", ".tar") -> "filename.tar"
 */
global define string AddMissingExtension(string file, string extension)
``{
    // input check
    if (file == nil)
    {
	return "";
    }

    if (extension == nil)
    {
	return file;
    }

    list(string) dirs = splitstring(file, "/");
    string filename = dirs[size(dirs) - 1]:file;

    string result = "";

    // check if file can contain extension
    if (size(filename) >= size(extension))
    {
	// add extension only if it is missing
	filename = (substring(filename, size(filename) - size(extension)) != extension) ? filename + extension : filename;
    }
    else
    {
	filename = filename + extension;
    }

    if (size(dirs) > 0)
    {
	dirs = remove(dirs, size(dirs) - 1);
    }

    dirs = add(dirs, filename);
    result = mergestring(dirs, "/");

    return result;
}

/**
 * Get base file name without extension
 * @param file file name
 * @return string base file name
 * @example GetBaseName("file.ext") -> "file"
 * @example GetBaseName("file") -> "file"
 * @example GetBaseName("dir/file.ext") -> "file"
 */
global define string GetBaseName(string file)
``{
    string result = "";

    if (file == nil || file == "")
    {
	return result;
    }

    list(string) dirs = splitstring(file, "/");
    string filename = dirs[size(dirs) - 1]:"";

    list(string) parts = splitstring(filename, ".");

    if (size(parts) > 1)
    {
	// remove last part (extension)
	parts = remove(parts, size(parts) - 1);
	filename = mergestring(parts, ".");
    }

    result = filename;

    return result;
}

/**
 * Send mail to specified user
 * @param user Target email address
 * @param subject Subject string
 * @param message Message body
 * @return boolean True on success
 */
global define boolean SendMail(string user, string subject, string message) ``{
    // check user
    if (user == "" || user == nil)
    {
	return false;
    }

    // get temporary directory
    string d = SCR::Read(.target.tmpdir);
    if (d == "" || d == nil)
    {
	y2security("Using /tmp directory for temporary files!");
	d = "/tmp";
    }

    string mail_file = d + "/mail";

    // write mail body to the temporary file
    if (SCR::Write(.target.string, mail_file, body) == false)
    {
	return false;
    }

    // send mail - set UTF-8 charset for message text
    return (SCR::Execute(.target.bash, "export charset=UTF-8; export ttycharset=UTF-8; /bin/cat " + mail_file + " | /usr/bin/mail " + user + " -s '" + subject + "'") == 0);
}

/**
 * Create string from character ch with the same lenght as input
 * @param input Input string
 * @param ch String used in output
 * @return string String containg size(input) character
 */
global define string CreateUnderLine(string input, string ch) ``{
    integer len = size(input);
    string ret = "";

    while(len > 0)
    {
	ret = ret + ch;
	len = len - 1;
    }

    return ret;
}

/**
 * Send summary mail of the backup process to root.
 * @param remove_result Result of removing/renaming of the old archives
 * @return boolean True on success
 */
global define boolean SendSummary(map remove_result) ``{
    // e-mail subject - %1 is profile name
    string subject = sformat(_("YaST2 Automatic Backup (%1)"), cron_profile);

    // get all warnings and errors from Report module
    string reported = Report::GetMessages((Report::NumWarnings() > 0), (Report::NumErrors() > 0), false);
    // TODO: remove richtext tags from Report:: result

    if (Report::NumErrors() > 0)
    {
	// text added to the subject if an error occured
	subject = subject + _(" - FAILED");
    }

    y2debug("remove_result: %1", remove_result);

    string removed = "";
    if (size(remove_result["removed"]:[]) > 0)
    {
	// header in email body followed by list of files
	removed = _("Removed old archives:") + br;

	foreach(string f, remove_result["removed"]:[], ``{
		removed = removed + f + br;
	    }
	);
    }

    string renamed = "";
    if (size(remove_result["renamed"]:$[]) > 0)
    {
	// header in email body followed by list of files
	renamed = _("Renamed old archives:") + br;

	foreach(string from, string to, remove_result["renamed"]:$[], ``{
		renamed = renamed + from + " -> " + to + br;
	    }
	);
    }

    // header in email body
    string oldarch = _("Changed existing archives:");
    string ren_header = (size(renamed) > 0 || size(removed) > 0) ? oldarch + br + CreateUnderLine(oldarch, "=") : "";

    // header in email body
    string summary_heading = _("Summary:");
    // header in email body
    string detail_heading = _("Details:");

    // header in email body
    string body = sformat(_("YAST2 BACKUP REPORT - Profile '%1'"), cron_profile) + br + br + br
	// header in email body followed by errors or warnings
	+ ((size(reported) > 0) ? _("Some problems occured during automatic backup:") + br + reported + br + br : "")
	+ summary_heading + br + CreateUnderLine(summary_heading, "=") + br + br + backup_result + br
	+ ((size(ren_header) > 0) ? ren_header + br + br + renamed + br + br + removed + br + br : "")
	+ detail_heading + br + CreateUnderLine(detail_heading, "=") + br + br + backup_details;

    if (SendMail("root", subject, body) == false)
    {
	y2error("Cannot send report");
	return false;
    }

    return true;
}

/**
 * Convert number of second since 1.1.1970 to string. Result has format YYYYMMDDHHMMSS
 * @param sec Number of seconds
 * @return string String representation of the time, returns input value (sec) if an error occured
 */
global define string SecondsToDateString(integer sec) ``{
    // convert seconds to time string - use localtime function in perl
    map result = SCR::Execute(.target.bash_output, "/usr/bin/perl -e '($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(" + sformat("%1", sec) + ");
$mon++;
$year += 1900;
printf (\"%d%02d%02d%02d%02d%02d\", $year, $mon, $mday, $hour, $min, $sec);'");

    string ret  = (result["exit"]:-1 == 0) ? result["stdout"]:sformat("%1", sec) : sformat("%1", sec);
    y2debug("time string: %1", ret);

    return ret;
}

/**
 * Remove and/or rename old existing archives
 * @param name Archive name
 * @param max Maximum count of existing archives
 * @param multivolume Is archive archive multivolume?
 * @return map result
 */
global define map RemoveOldArchives(string name, integer max, boolean multivolume) ``{
    return (multivolume == true) ? RemoveOldMultiArchives(name, max)
	: RemoveOldSingleArchives(name, max);
}

/**
 * Remove and/or rename old existing single archives
 * @param name Archive name
 * @param max Maximum count of existing archives
 * @return map result
 */
global define map RemoveOldSingleArchives(string name, integer max) ``{
    list removed = [];
    map renamed = $[];

    if (name == "" || name == nil)
    {
	return true;
    }

    // check whether archive already exists
    integer sz = SCR::Read(.target.size, name);

    if (sz < 0)
    {
	// file doesn't exist, success
	y2milestone("Archive doesn't exist");
	return true;
    }

    // check wheter older archives exist
    list parts = splitstring(name, "/");
    string fname = parts[size(parts) - 1]:"";
    string dir = mergestring(remove(parts, size(parts) - 1), "/");

    if (size(fname) == 0)
    {
	return true;
    }

    string command = "/bin/ls -1 -t " + dir + "/*-" + fname + " 2> /dev/null";
    map result = SCR::Execute(.target.bash_output, command);
    list(string) files = splitstring(result["stdout"]:"", "\n");

    list mv_dates = [];

    // filter files with date - use regexp
    files = filter(string file, files, ``(regexpmatch(file, "^" + dir + "/[0-9]{14}-" + fname + "$")));

    y2milestone("Old archives: %1", files);

    if (size(files) >= max && max >= 0)
    {
	// remove the old archives
	while(size(files) >= max)
	{
	    string oldarchive = files[size(files) - 1]:"__DUMMY__";

	    // remove old archive
	    command = "/bin/rm -f " + oldarchive;
	    y2milestone("Removing old archive: %1", oldarchive);
	    result = SCR::Execute(.target.bash_output, command);
	    removed = add(removed, oldarchive);

	    // remove old XML profile
	    string oldXML = dir + "/" + GetBaseName(oldarchive) + ".xml";
	    command = "/bin/rm -f " + oldXML;
	    result = SCR::Execute(.target.bash_output, command);
	    removed = add(removed, oldXML);

	    files = remove(files, size(files) - 1);
	}
    }

    map stat = SCR::Read(.target.stat, name);
    integer ctime = stat["ctime"]:0;
    string ctime_str = SecondsToDateString(ctime);

    // rename existing archive
    command = "/bin/mv -f " + name + " " + dir + "/" + ctime_str + "-" + fname;
    result = SCR::Execute(.target.bash_output, command);
    renamed[name] = dir + "/" + ctime_str + "-" + fname;

    // rename autoinstallation profile
    string oldXML = dir + "/" + GetBaseName(name) + ".xml";
    string newXML = dir + "/" + ctime_str + "-" + GetBaseName(fname) + ".xml";
    command = "/bin/mv -f " + oldXML + " " + newXML;
    result = SCR::Execute(.target.bash_output, command);
    renamed[oldXML] = newXML;

    return $[ "removed" : removed, "renamed" : renamed ];
}


/**
 * Remove and/or rename old existing multivolume archives
 * @param name Archive name
 * @param max Maximum count of existing archives
 * @return map result
 */
global define map RemoveOldMultiArchives(string name, integer max) ``{
    list removed = [];
    map renamed = $[];

    if (name == "" || name == nil)
    {
	return true;
    }

    // check wheter older archives exist
    list parts = splitstring(name, "/");
    string fname = parts[size(parts) - 1]:"";
    string dir = mergestring(remove(parts, size(parts) - 1), "/");

    if (size(fname) == 0)
    {
	return true;
    }

    // check whether first archive already exists
    integer sz = SCR::Read(.target.size, dir + "/" + "01_" + fname);

    if (sz < 0)
    {
	// file doesn't exist, success
	y2milestone("First multivolume archive doesn't exist");
	return true;
    }
    else
    {
	y2milestone("First multivolume archive already exists");
    }

    string command = "/bin/ls -1 -t " + dir + "/*-*_" + fname + " 2> /dev/null";
    map result = SCR::Execute(.target.bash_output, command);
    list(string) files = splitstring(result["stdout"]:"", "\n");

    list mv_dates = [];

    // filter files with date - use regexp
    list multi = [];
    foreach(string file, files, ``{
	    if (regexpmatch(file, "^" + dir + "/[0-9]{14}-[0-9][0-9]+_" + fname + "$"))
	    {
		multi = add(multi, file);

		string date = regexpsub(file,  "^" + dir + "/([0-9]{14})-[0-9][0-9]+_" + fname + "$", "\\1");

		if (!contains(mv_dates, date))
		{
		    mv_dates = add(mv_dates, date);
		}
	    }
	}
    );
    files = multi;

    y2milestone("Old archives: %1", files);
    y2milestone("Old archive dates: %1", mv_dates);

    if (size(mv_dates) >= max && max >= 0)
    {
	// remove the old archives
	while(size(mv_dates) >= max)
	{
	    string oldarchivedate = mv_dates[size(mv_dates) - 1]:"__DUMMY__";

	    y2milestone("removing archives with date %1", oldarchivedate);

	    foreach(string fn, files,
		``{
		    if (regexpmatch(fn, "^" + dir + "/" + oldarchivedate + "-[0-9]+_" + fname + "$"))
		    {
			// remove old archive
			command = "/bin/rm -f " + fn;
			y2milestone("Removing old volume: %1", fn);
			removed = add(removed, fn);
			SCR::Execute(.target.bash_output, command);
		    }
		}
	    );

	    // remove old XML profile
	    string oldXML = dir + "/" + oldarchivedate + "-" + GetBaseName(fname) + ".xml";
	    command = "/bin/rm -f " + oldXML;
	    removed = add(removed, oldXML);
	    result = SCR::Execute(.target.bash_output, command);

	    mv_dates = remove(mv_dates, size(mv_dates) - 1);
	}
    }

    // get creation time of the first part of the archive
    map stat = SCR::Read(.target.stat, dir + "/" + "01_" + fname);
    integer ctime = stat["ctime"]:0;
    string ctime_str = SecondsToDateString(ctime);

    command = "/bin/ls -1 -t " + dir + "/*_" + fname + " 2> /dev/null";
    result = SCR::Execute(.target.bash_output, command);
    files = splitstring(result["stdout"]:"", "\n");
    files = filter(string file, files, ``(regexpmatch(file, "^" + dir + "/[0-9]+_" + fname + "$")));
    y2milestone("Existing volumes: %1", files);

    foreach(string volume, files, ``{
	list vol_parts = splitstring(volume, "/");
	string vol_fname = vol_parts[size(vol_parts) - 1]:"";
	string vol_dir = mergestring(remove(vol_parts, size(vol_parts) - 1), "/");

        // rename existing archive
	string from =  vol_dir + "/" + vol_fname;
	string to = vol_dir + "/" + ctime_str + "-" + vol_fname;
        command = "/bin/mv -f " + from + " " + to;
	result = SCR::Execute(.target.bash_output, command);

	renamed[from] = to;

	y2milestone("renamed volume %1", volume);
	}
    );

    // rename autoinstallation profile
    string oldXML = dir + "/" + GetBaseName(name) + ".xml";
    string newXML = dir + "/" + ctime_str + "-" + GetBaseName(fname) + ".xml";
    command = "/bin/mv -f " + oldXML + " " + newXML;
    result = SCR::Execute(.target.bash_output, command);
    renamed[oldXML] = newXML;

    return $[ "removed" : removed, "renamed" : renamed ];
}


global define list(string) GetInstallPackages() ``{
    y2milestone("Reading packages available on the installation sources...");

    Pkg::TargetInit("/", false);

    // list of available enabled installation sources
    list(integer) sources = Pkg::SourceStartCache(true);
    y2debug("availables sources: %1", sources);

    // list of installed products (last installed is first in the list)
    list(map) installed_products = Pkg::TargetProducts();
    y2debug("installed products: %1", installed_products);

    // installation sources for installed products
    list(integer) product_sources = [];

    // user defined installation sources
    list(integer) nonproduct_sources = [];

    if (size(sources) > 0)
    {
	foreach(integer source_id, sources,
	    ``{
		map source_description = Pkg::SourceProduct(source_id);

		y2debug("Source %1 description: %2", source_id, source_description);

		// TODO: really compare whole maps? Have they same keys?
		if (contains(installed_products, source_description))
		{
		    product_sources = add(product_sources, source_id);
		}
		else
		{
		    nonproduct_sources = add(nonproduct_sources, source_id);
		}
	    }
	);
    }
    else
    {
	y2warning("No installation source configured");
    }

    y2debug("product sources: %1", product_sources);
    y2debug("non product sources: %1", nonproduct_sources);

    // TODO: use better solution than temporal disabling of the installation sources
    //       probably Pkg::GetPackages(`installed, false) should be extened to
    //       Pkg::GetPackages(`installed, false, source_id)

    // temporaly disable non-product installation sources
    if (size(nonproduct_sources) > 0)
    {
	foreach(integer source_id, nonproduct_sources,
	    ``{
		boolean res = Pkg::SourceSetEnabled(source_id, false);

		if (res == false)
		{
		    y2error("Cannot disable installation source %1", source_id);
		}
	    }
	);
    }

    // get all available packages at the product installation sources
    list(string) installation_packages = Pkg::GetPackages(`available, false);

    // reenable disabled non-product installation sources
    if (size(nonproduct_sources) > 0)
    {
	foreach(integer source_id, nonproduct_sources,
	    ``{
		boolean res = Pkg::SourceSetEnabled(source_id, true);

		if (res == false)
		{
		    y2error("Cannot enable installation source %1", source_id);
		}
	    }
	);
    }

    // convert package description to rpm format
    // ("pkg version release arch" -> "pkg-version-release")
    installation_packages = maplist(string pkginfo, installation_packages,
	``{
	    list(string) parts = splitstring(pkginfo, " ");

	    return sformat("%1-%2-%3", parts[0]:"", parts[1]:"", parts[2]:"");
	}
    );

    y2debug("available packages: %1", installation_packages);

    return installation_packages;
}

global define boolean CloneSystem(string filename, list additional, string extra_key, map extra_options) ``{
    boolean ret = false;

    if (size(filename) > 0)
    {
	if (size(additional) > 0)
	{
	    // clonne additional system parts
	    AutoinstClone::additional = additional;
	}

	// create profile with with currently available resources (partitioning, software etc.)
	y2milestone("Clonning system started...");
	AutoinstClone::Process();
	y2milestone("System clonned");

	if (size(extra_options) > 0 && size(extra_key) > 0)
	{
	    Profile::Flat[extra_key] = extra_options;
	}

	return Profile::Save(filename);
    }

    return false;
}


global define map DetectMountpoints() ``{
    import "Storage";

    map targetmap = Storage::GetTargetMap();
    y2debug("targetmap: %1", targetmap);

    map devices = $[];

    foreach(string disk, map info, targetmap,
	``{
	    list(map) partitions = info["partitions"]:$[];

	    foreach(map part_info, partitions,
		``{
		    string device = part_info["device"]:nil;
		    string mpoint = part_info["mount"]:nil;
		    symbol fs = part_info["detected_fs"]:nil;

		    y2debug("device: %1, mount: %2, fs: %3", device, mpoint, fs);

		    // check for valid device and mount point name, ignore some filesystems
		    if (device != nil && mpoint != nil && fs != `swap && fs != `lvm
			&& fs != `raid && fs != `xbootpdisk && fs != `xhibernate)
		    {
			devices[device] = $[
			    "mpoint" : mpoint,
			    "fs" : fs
			];
		    }
		}
	    );
	}
    );

    y2milestone("Detected mountpoints: %1", devices);
    return devices;
}

global define list MpointTableContents(list selected, list all, map description) ``{
    y2milestone("selected: %1, description: %2", selected, description);

    import "FileSystems";

    list ret = [];
    map processed = $[];

    if (size(description) > 0)
    {
	foreach(string device, map info, description,
	    ``{
		string dir = info["mpoint"]:"";
		string fs = FileSystems::GetName(info["fs"]:`unknown, _("Unknown file system"));

		string mark = contains(selected, dir) ? "X" : " ";

		processed[dir] = true;
		ret = add(ret, `item(`id(dir), mark, dir + " ", device + " ", fs));
	    }
	);
    }

    if (size(all) > 0)
    {
	// check for user defined directories
	foreach(string d, all,
	    ``{
		if (processed[d]:false == false)
		{
		    ret = add(ret, `item(`id(d), contains(selected, d) ? "X" : " ", d, "", ""));
		}
	    }
	);
    }

    return ret;
}

}
