/**
 *  File:
 *    functions.ycp
 *
 *  Module:
 *    Backup module
 *
 *  Authors:
 *    Ladislav Slezak <lslezak@suse.cz>
 *
 *  $Id$
 *
 *  Functions used by backup module.
 */


{

/**
 * This function returns list of items for Table widget. Each item contains id, selection mark, file name and package name.
 * Used global variables: nocheckmark, checkmark, backup_files, selected_files
 * @param check If true then add check mark to the first column. If check is nil, then check mark is added only if file is in selected_files.
 * @return list List of items
 */

global define MapToTableItems(boolean check) ``{
    integer idx = 0;
    list items = [];

    if (backup_files == nil)
    {
	return [];
    }

    foreach(`key, `val, backup_files,
	``{
	    list ch = lookup(val, "changed_files", []);

	    if (ch != nil)
	    {
		foreach(`file, ch,
		    ``{
			idx = idx + 1;

			string mark = "";

			if (check == nil)
			{
			    mark = (contains(lookup(lookup(selected_files, key, $[]), "changed_files", []), file) == true) ? checkmark : nocheckmark;
			}
			else
			{
			    mark = check ? checkmark : nocheckmark;
			}

			items = add(items, `item(`id(idx), mark, file, key));
		    }
		);
	    }
	}
    );

    return items;
}


/**
 * Display abort confirmation dialog
 * @param type Select dialog message, possible values: `not_created, `broken, `no_change or `none for none dialog
 * @return boolean False if user select to not abort, true otherwise.
 */

global define AbortConfirmation(symbol type) ``{

    boolean ret = nil;

    string heading = _("Abort confirmation");
    string question = _("Do you really want to abort backup?");
    string yes = _("Yes");
    string no = _("No");

    if (type == `not_created)
    {
	ret = UI::AnyQuestionPopup(heading, question + "\n" + _("Backup archive will not be created!"), yes, no, `focus_no);
    }
    else
    {
	if (type == `broken)
	{
	    ret = UI::AnyQuestionPopup(heading, question + "\n" + _("Backup archive will be broken!"), yes, no, `focus_no);
	}
	else
	{
	    if (type == `no_change)
	    {
		ret = UI::AnyQuestionPopup(heading, question, yes, no, `focus_yes);
	    }
	    else
	    {
		if (type == `none)
		{
		    ret = true;
		}
		else
		{
		    y2warning("Unknown type of abort confirmation dialog: %1", type);
		}
	    }
	}
    }

    return ret;
}


/**
 * Ask user for some value: display dialog with label, text entry and OK/Cancel buttons.
 * @param label Displayed text above the text entry in the dialog
 * @param value Default text in text entry, for empty text set value to "" or nil
 * @return map Returned map: $[ "text" : string, "clicked" : symbol ]. Value with key text is string entered by user, symbol is `ok or `cancel depending which button was pressed.
 */

global define ShowEditDialog(string label, string value) ``{

    if (label == nil)
    {
	label = "";
    }

    if (value == nil)
    {
	value = "";
    }

    UI::OpenDialog(
	`VBox(
	    `TextEntry(`id(`te), label, value),
	    `VSpacing(1.0),
	    `HBox(
	        `PushButton(`id(`ok), "Ok"),
		`PushButton(`id(`cancel), "Cancel")
	    )
	)
    );

    symbol input = UI::UserInput();

    string text = UI::QueryWidget(`id(`te), `Value);
    UI::CloseDialog();

    return $[ "text" : text, "clicked" : input ];
}



/**
 * Wait for output from subprocess or user action. If user press `abort button, then subprocess is terminated.
 * @param wait Delay in miliseconds between user action checks (if no output from subprocess is available)
 * @param abort_question Symbol for AbortConfirmation function - determine which messgae will be displayed if Abort button was pressed
 * @return symbol Pressed button id or nil if some data is ready from subprocess.
 */

global define waitForUserOrProcess(integer wait, symbol abort_question) ``{
    symbol ret = nil;

    while (SCR::Read(.background.newlines) == 0 && SCR::Read(.background.output_open))
    {
	sleep(wait);

	ret = UI::PollInput();

	if (ret == `abort)
	{
	    if (AbortConfirmation(abort_question))
	    {
		SCR::Execute(.background.kill, nil);
		break;
	    }
	    else
	    {
		ret = nil;
	    }
	}
    }

    return ret;
}


/**
 * Returns list of mounted file systems types.
 * @return list List of strings, each mounted file system type is reported only onetimes, list is alphabetically sorted.
 * @example GetMountedFilesystems() -> [ "devpts", "ext2", "nfs", "proc", "reiserfs" ]
 */

global define GetMountedFilesystems() ``{
    list mounted = SCR::Read(.proc.mounts);
    list result = [ ];

    if (mounted == nil)
    {
	return [];
    }

    foreach(`m, mounted,
	``{
	    string fs = lookup(m, "vfstype", nil);

	    if (fs != nil)
	    {
		result = add(result, fs);
	    }
	}
    );

    return toset(result);
}


/**
 * Returns list of Ext2 mountpoints
 * @return list List of alphabetically sorted strings
 * @example GetMountedExt2Filesystems() -> [ "/dev/hda1", "/dev/hda4" ]
 */

global define GetMountedExt2Filesystems() ``{
    list mounted = SCR::Read(.proc.mounts);
    list result = [ ];

    if (mounted == nil)
    {
	return [];
    }

    foreach(`m, mounted,
	``{
	    string fs = lookup(m, "vfstype", nil);
	    string dev = lookup(m, "spec", nil);

	    if (fs == "ext2" && dev != nil)
	    {
		result = add(result, dev);
	    }
	}
    );

    return toset(result);
}


/**
 * This function reads two lists: full list and selection list (contains subset of items in full list). Returned list can be used in MultiSelectionBox widget.
 * @return list List of alphabetically sorted strings
 * @param in List of items
 * @param selected List with subset of items from list in.
 * @example GetListWithFlags(["/dev", "/etc"], ["/etc"]) -> [`item (`id ("/dev"), "/dev", false), `item (`id ("/etc"), "/etc", true)]
 */

global define GetListWithFlags(list in, list selected) ``{

    if (in == nil)
    {
	return [];
    }

    return maplist(`i, in, ``{
	return `item(`id(i), i, (contains(selected, i) ? true : false));
    });
}

/**
 * Set boolean value val to all items in list.
 * @return list List of items
 * @param in Input list of items
 * @param val Requested value
 * @example AddIdBool( [ `item(`id("ext2"), "ext2", true) ], false) ) -> [ `item (`id ("ext2"), "ext2", false) ]
 */

global define AddIdBool(list in, boolean val) ``{
    if (val == nil)
    {
	val = false;
    }

    if (in == nil)
    {
	return [];
    }

    return maplist(`i, in, ``{
        return (is(i, term)) ? `item(select(i, 0), select(i, 1), val) : nil;
    });
}


/**
 * Returns list of items from list of values.
 * @return list List of items
 * @param in Input list of values
 * @example AddId("abc", "123") -> [`item(`id("abc"), "abc"), `item(`id("123"), "123")]
 */

global define AddId(list in) ``{

    if (in == nil) return [];

    return maplist(`i, in, ``{
        return `item(`id(i), i);
    });
}


/**
 * Returns string generated from selected files list. String is in format which is accepted by backup_archive.pl script. Used global variables: selected_files, backup_files.
 * @return string String with multiple lines
 * @see <a href="../backup_specification.html">Backup module specification</a>
 */

global define MapFilesToString() ``{
    string result = "";

    if (selected_files == nil || backup_files == nil)
    {
	return "";
    }

    foreach(`pkg, `info, selected_files,
        ``{
            if (pkg != "")
            {
		string tmp = "Package: " + pkg + "\nInstalled: "
		    + lookup(lookup(backup_files, pkg, $[]), "install_prefixes", "(none)") + "\n";

                foreach(`file, lookup(info, "changed_files", []), ``{tmp = tmp + file + "\n";});

		result = result + tmp;
            }
        }
    );

    list nopkg = lookup(lookup(selected_files, "", $[ ]), "changed_files", []);

    if (size(nopkg) > 0)
    {
	string tmp = "Nopackage:\n";
        foreach(`file, nopkg, ``{tmp = tmp +  file + "\n";});

	result = result + tmp;
    }

    return result;
}


/**
 * Convert media description list to ComboBox items list
 * @param media Medium descriptions - list of maps with keys (and values): "label" (description string), "symbol" (identification symbol), "capacity" (size of free space on empty medium)
 * @return list Items list for UI widgets
 */

global define MediaList2UIList(list media) ``{
    list result = [];

    if (media == nil)
    {
	return [];
    }

    foreach(`v, media,
	``{
	    if (is(v, map))
	    {
		symbol i = lookup(v, "symbol", nil);
		string l = lookup(v, "label", nil);

		if (i != nil && l != nil)
		{
		    result = add(result, `item(`id(i), l));
		}
	    }
	}
    );

    return result;
}


/**
 * Set state of depending widgets in Multiple volume options dialog
 */

global define SetMultiWidgetsState() ``{
    boolean tmp_multi = UI::QueryWidget(`id(`multi_volume), `Value);
    UI::ChangeWidget(`id(`vol), `Enabled, tmp_multi);

    boolean user = (tmp_multi && UI::QueryWidget(`id(`vol), `Value) == `user_defined);
    UI::ChangeWidget(`id(`user_size), `Enabled, user);
    UI::ChangeWidget(`id(`user_unit), `Enabled, user);
}


/**
 * Return capacity of required medium
 * @param media Medium descriptions
 * @param m Identification of required medium
 */

global define GetCapacity(list media, symbol m) ``{
    integer result = nil;

    if (media != nil)
    {
	foreach(`val, media,
	    ``{
		if (is(val, map) && lookup(val, "symbol", nil) == m)
		{
		    result = lookup(val, "capacity", nil);
		}
	    }
	);
    }

    return result;
}

}

