/**
 *  File:
 *    functions.ycp
 *
 *  Module:
 *    Backup module
 *
 *  Authors:
 *    Ladislav Slezak <lslezak@suse.cz>
 *
 *  $Id$
 *
 *  Functions used by backup module.
 */


{

include "ui/common_messages.ycp";

textdomain "backup";

/**
 * This function returns list of items for Table widget. Each item contains id, selection mark, file name and package name.
 * Used global variables: nocheckmark, checkmark, backup_files, selected_files
 * @param check If true then add check mark to the first column. If check is nil, then check mark is added only if file is in selected_files.
 * @return list List of items
 */

global define list MapToTableItems(boolean check) ``{
    integer idx = 0;
    list items = [];

    if (Backup::backup_files == nil)
    {
	return [];
    }

    foreach(`key, `val, Backup::backup_files,
	``{
	    list ch = lookup(val, "changed_files", []);

	    if (ch != nil)
	    {
		foreach(`file, ch,
		    ``{
			idx = idx + 1;

			string mark = "";

			if (check == nil)
			{
			    mark = (contains(lookup(lookup(Backup::selected_files, key, $[]), "changed_files", []), file) == true) ? checkmark : nocheckmark;
			}
			else
			{
			    mark = check ? checkmark : nocheckmark;
			}

			items = add(items, `item(`id(idx), mark, file, key));
		    }
		);
	    }
	}
    );

    return items;
}


/**
 * Display abort confirmation dialog
 * @param type Select dialog type, possible values: `changed, `not_changed or `none for none dialog
 * @return boolean False if user select to not abort, true otherwise.
 */

global define boolean AbortConfirmation(symbol type) ``{

    boolean ret = nil;

    // popup dialog header
    string heading = _("Abort confirmation");
    // popup dialog question
    string question = _("Do you really want to abort the backup?");
    string yes = YesButtonLabel();	// from common_messages.ycp
    string no = NoButtonLabel();

    if (type == `changed)
    {
	ret = UI::AnyQuestionPopup(heading, question, yes, no, `focus_no);
    }
    else
    {
	if (type == `not_changed)
	{
	    ret = UI::AnyQuestionPopup(heading, question, yes, no, `focus_yes);
	}
	else
	{
	    if (type == `none)
	    {
		ret = true;
	    }
	    else
	    {
		y2warning("Unknown type of abort confirmation dialog: %1", type);
	    }
	}
    }

    return ret;
}


/**
 * Ask user for some value: display dialog with label, text entry and OK/Cancel buttons.
 * @param label Displayed text above the text entry in the dialog
 * @param value Default text in text entry, for empty text set value to "" or nil
 * @return map Returned map: $[ "text" : string, "clicked" : symbol ]. Value with key text is string entered by user, symbol is `ok or `cancel depending which button was pressed.
 */

global define map ShowEditDialog(string label, string value) ``{

    if (label == nil)
    {
	label = "";
    }

    if (value == nil)
    {
	value = "";
    }

    UI::OpenDialog(
	`VBox(
	    `TextEntry(`id(`te), label, value),
	    `VSpacing(1.0),
	    `HBox(
	        `PushButton(`id(`ok), `opt(`default, `key_F10), OKButtonLabel()),
		`PushButton(`id(`cancel), `opt(`key_F9), CancelButtonLabel())
	    )
	)
    );

    UI::SetFocus(`id(`te));

    symbol input = UI::UserInput();

    string text = UI::QueryWidget(`id(`te), `Value);
    UI::CloseDialog();

    return $[ "text" : text, "clicked" : input ];
}



/**
 * Wait for output from subprocess or user action. If user press `abort button, then subprocess is terminated.
 * @param wait Delay in miliseconds between user action checks (if no output from subprocess is available)
 * @param abort_question Symbol for AbortConfirmation function - which dialog will be displayed if Abort button is pressed
 * @return symbol Pressed button id or nil if some data is ready from subprocess.
 */

global define symbol waitForUserOrProcess(integer wait, symbol abort_question) ``{
    symbol ret = nil;

    while (SCR::Read(.background.newlines) == 0 && SCR::Read(.background.output_open))
    {
	sleep(wait);

	ret = UI::PollInput();

	if (ret == `abort || ret == `cancel)
	{
	    ret = `abort;

	    if (AbortConfirmation(abort_question))
	    {
		SCR::Execute(.background.kill, nil);
		break;
	    }
	    else
	    {
		ret = nil;
	    }
	}
    }

    return ret;
}


/**
 * Returns list of mounted file systems types.
 * @return list List of strings, each mounted file system type is reported only onetimes, list is alphabetically sorted.
 * @example GetMountedFilesystems() -> [ "devpts", "ext2", "nfs", "proc", "reiserfs" ]
 */

global define list GetMountedFilesystems() ``{
    list mounted = SCR::Read(.proc.mounts);
    list result = [ ];

    if (mounted == nil)
    {
	return [];
    }

    foreach(`m, mounted,
	``{
	    string fs = lookup(m, "vfstype", nil);

	    if (fs != nil)
	    {
		result = add(result, fs);
	    }
	}
    );

    return toset(result);
}


/**
 * Returns list of Ext2 mountpoints - actually mounted and from /etc/fstab file
 * @return list List of strings
 * @example Ext2Filesystems() -> [ "/dev/hda1", "/dev/hda4" ]
 */

global define list Ext2Filesystems() ``{
    list mounted = SCR::Read(.proc.mounts);
    list result = [ ];
    list tmp_parts = [];

    if (mounted != nil)
    {
	foreach(`m, mounted,
	    ``{
		string fs = lookup(m, "vfstype", nil);
		string dev = lookup(m, "spec", nil);
		string file = lookup(m, "file", nil);

		if (fs == "ext2" && dev != nil && !contains(tmp_parts, dev))
		{
		    result = add(result, $[ "partition" : dev, "mountpoint" : file ]);
		    tmp_parts = add(tmp_parts, dev);
		}
	    }
	);
    }

    list fstab = SCR::Read(.etc.fstab);

    if (fstab != nil)
    {
	foreach(`f, fstab,
	    ``{
		string fs = lookup(f, "vfstype", nil);
		string dev = lookup(f, "spec", nil);
		string file = lookup(f, "file", nil);

		if (fs == "ext2" && dev != nil && !contains(tmp_parts, dev))
		{
		    result = add(result, $[ "partition" : dev, "mountpoint" : file ]);
		    tmp_parts = add(tmp_parts, dev);
		}
	    }
	);
    }

    return result;
}


/**
 * This function reads two lists: full list and selection list (contains subset of items in full list). Returned list can be used in MultiSelectionBox widget.
 * @return list List of alphabetically sorted strings
 * @param in List of items
 * @param selected List with subset of items from list in.
 * @example GetListWithFlags(["/dev", "/etc"], ["/etc"]) -> [`item (`id ("/dev"), "/dev", false), `item (`id ("/etc"), "/etc", true)]
 */

global define list GetListWithFlags(list in, list selected) ``{

    if (in == nil)
    {
	return [];
    }

    return maplist(`i, in, ``{
	return `item(`id(i), i, (contains(selected, i) ? true : false));
    });
}

/**
 * Set boolean value val to all items in list.
 * @return list List of items
 * @param in Input list of items
 * @param val Requested value
 * @example AddIdBool( [ `item(`id("ext2"), "ext2", true) ], false) ) -> [ `item (`id ("ext2"), "ext2", false) ]
 */

global define list AddIdBool(list in, boolean val) ``{
    if (val == nil)
    {
	val = false;
    }

    if (in == nil)
    {
	return [];
    }

    return maplist(`i, in, ``{
	term tmp_id = nil;
	string tmp_s = nil;

	boolean isterm = is(i,term);

	if (isterm)
	{
	    tmp_id = select(i, 0, nil);
	    tmp_s = select(i, 1, nil);
	}

        return (isterm && tmp_id != nil && tmp_s != nil) ? `item(tmp_id, tmp_s, val) : nil;
    });
}


/**
 * Returns list of items from list of values.
 * @return list List of items
 * @param in Input list of values
 * @example AddId("abc", "123") -> [`item(`id("abc"), "abc"), `item(`id("123"), "123")]
 */

global define list AddId(list in) ``{
    if (in == nil) return [];

    return maplist(`i, in, ``{
	return `item(`id(i), i);
    });
}


/**
 * Returns list of items from list of values.
 * @return list List of items
 * @param in Input list of maps with keys "partition", "mountpoints" and strings as values
 * @example AddId([ $["partition" : "/dev/hda3", "mountpoint" : "/usr"] ]) -> [`item(`id("/dev/hda3"), "/dev/hda3", "/usr")]
 */

global define list AddIdExt2(list in) ``{

    if (in == nil) return [];

    return maplist(`i, in, ``{
	string pt = lookup(i, "partition", nil);
	string mp = lookup(i, "mountpoint", nil);

        return `item(`id(pt), pt, mp);
    });
}

/**
 * Returns string generated from selected files list. String is in format which is accepted by backup_archive.pl script. Used global variables: selected_files, backup_files.
 * @return string String with multiple lines
 * @see <a href="../backup_specification.html">Backup module specification</a>
 */

global define string MapFilesToString() ``{
    string result = "";

    if (Backup::selected_files == nil || Backup::backup_files == nil || list_of_installed_packages == nil)
    {
	return "";
    }

    foreach(`pkg, `info, Backup::selected_files,
        ``{
            if (pkg != "")
            {
		string tmp = "Package: " + pkg + "\nInstalled: "
		    + lookup(lookup(Backup::backup_files, pkg, $[]), "install_prefixes", "(none)") + "\n";

                foreach(`file, lookup(info, "changed_files", []), ``{tmp = tmp + file + "\n";});

		result = result + tmp;
            }
        }
    );

    list nopkg = lookup(lookup(Backup::selected_files, "", $[ ]), "changed_files", []);

    if (size(nopkg) > 0)
    {
	string tmp = "Nopackage:\n";
        foreach(`file, nopkg, ``{tmp = tmp + file + "\n";} );

	result = result + tmp;
    }

    return result;
}


/**
 * Convert media description list to ComboBox items list
 * @param media Medium descriptions - list of maps with keys (and values): "label" (description string), "symbol" (identification symbol), "capacity" (size of free space on empty medium)
 * @return list Items list for UI widgets
 */

global define list MediaList2UIList(list media) ``{
    list result = [];

    if (media == nil)
    {
	return [];
    }

    foreach(`v, media,
	``{
	    if (is(v, map))
	    {
		symbol i = lookup(v, "symbol", nil);
		string l = lookup(v, "label", nil);

		if (i != nil && l != nil)
		{
		    result = add(result, `item(`id(i), l));
		}
	    }
	}
    );

    return result;
}


/**
 * Set state of depending widgets in Multiple volume options dialog
 * @return void
 */

global define void SetMultiWidgetsState() ``{
    boolean tmp_multi = UI::QueryWidget(`id(`multi_volume), `Value);
    UI::ChangeWidget(`id(`vol), `Enabled, tmp_multi);

    boolean user = (tmp_multi && UI::QueryWidget(`id(`vol), `Value) == `user_defined);
    UI::ChangeWidget(`id(`user_size), `Enabled, user);
    UI::ChangeWidget(`id(`user_unit), `Enabled, user);
}

/**
 * Return mount point for Ext2 partition. This function at first checks if partition is mounted. If yes it returns actual mout point, if no it searches mount point from /etc/fstab file.
 * @param device_name Name of device
 * @return string Mount point of device or nil if device does not exist or there is other file system than Ext2
 * @example Ext2MountPoint("/dev/hda1") -> "/boot"
 */

global define string Ext2MountPoint(string device_name) ``{
    // chack if partition is now mounted
    list mp = SCR::Read(.proc.mounts);
    string result = nil;

    if (mp != nil)
    {
	foreach(`p, mp,
	    ``{
		string d = lookup(p, "file", nil);
		string dev = lookup(p, "spec", nil);
		string fs = lookup(p, "vfstype", nil);

		if (fs == "ext2" && dev == device_name)
		{
		    result = d;
		}
	    }
	);
    }

    // if partition is not mounted then search mount point from fstab
    if (result == nil)
    {
	list fstab = SCR::Read(.etc.fstab);

	if (fstab != nil)
	{
	    foreach(`p, fstab,
		``{
		    string d = lookup(p, "file", nil);
		    string dev = lookup(p, "spec", nil);
		    string fs = lookup(p, "vfstype", nil);

		    if (fs == "ext2" && dev == device_name)
		    {
			result = d;
		    }
		}
	    );
	}
    }

    return result;
}


}

