/**
 *  File:
 *    Backup.ycp
 *
 *  Module:
 *    Backup module
 *
 *  Authors:
 *    Ladislav Slezak <lslezak@suse.cz>
 *
 *  $Id$
 *
 *  Main file for backup module
 *
 */


{

module	"Backup";

import "AIClone";
import "Lan";
import "Progress";

textdomain "backup";

global string script_store_ext2_area = "/sbin/e2image";
global string script_get_partition_table = "/sbin/fdisk -l";
global string script_get_files = "/usr/lib/YaST2/bin/backup_search.pl";
global string script_create_archive = "/usr/lib/YaST2/bin/backup_archive.pl";

// global variables initialized to default values:
global string archive_name = "";		// archive file name
global string description = "";			// user comment
global symbol archive_type = `tgz;		// archive type

global boolean multi_volume = false;
global symbol volume_size = `fd144;
global string user_volume_size = "";
global symbol user_volume_unit = nil;


// media description - capacity is maximum file size which fits
// to formatted medium using widely used file system (FAT on floppies)

global list media_descriptions = [
    $[
	"label" : _("Floppy 1.44 MB"),
	"symbol" : `fd144,
	"capacity" : 1423 // 1457664B is exact size for FAT fs
    ],
    $[
	"label" : _("Floppy 1.2 MB"),
	"symbol" : `fd12,
	"capacity" : 1185 // 1213952B is exact size for FAT fs
    ],
    $[
	"label" : _("ZIP 100 MB"),
	"symbol" : `zip100,
	"capacity" : 95*1024	// exact size is 96MiB (64 heads, 32 sectors, 96 cylinders, 512B sector)
    ],
/*    $[
	"label" : _("ZIP 250 MB"),
	"symbol" : `zip250,
	"capacity" : ?????
    ],*/
    $[
	"label" : _("CD-R/RW 650 MB (74 min.)"),
	"symbol" : `cd650,
	"capacity" : 649*1024	// exact size is 650.4 MB - remaining space is for ISO fs
    ],
    $[
	"label" : _("CD-R/RW 700 MB (80 min.)"),
	"symbol" : `cd700,
	"capacity" : 702*1024	// exact size is 703.1 MB - remaining space is for ISO fs
    ]
];

global list units_description = [
    $[
	"label" : _("bytes"),
	"capacity" : 1,
	"symbol"   : `B
    ],
    $[
	"label" : _("kB"),
	"capacity" : 1000,
	"symbol"   : `kB
    ],
    $[
	"label" : _("kiB"),
	"capacity" : 1024,
	"symbol"   : `kiB
    ],
    $[
	"label" : _("MB"),
	"capacity" : 1000000,
	"symbol"   : `MB
    ],
    $[
	"label" : _("MiB"),
	"capacity" : 1024*1024,
	"symbol"   : `MiB
    ],
];

global boolean search = true;			// search files which do not belong to any package
global boolean system = false;			// backup system areas
global boolean display = false;		// display files before creating archive
global boolean do_md5_test = true;

global list default_dir = [ "/tmp", "/var/lock", "/var/run", "/var/tmp", "/var/cache" ];		// default excluded directoried from search
global list dir_list = nil;			// selected directoried to exclude

global list fs_exclude = [ "iso9660" ];			// selected filesystems to exclude from search
global list detected_fs = nil;			// detected filesystems

global list detected_ext2 = nil;		// detected mounted ext2 filesystems
global list ext2_backup = [];			// selected ext2 filesystems to backup

global boolean backup_pt = true;		// backup partition table

global boolean backup_all_ext2 = false;		// backup all mounted ext2 partitions
global boolean backup_none_ext2 = true;		// backup none ext2 partitions
global boolean backup_selected_ext2 = false;	// backup selected ext2 partitions


global map backup_files = $[ ];		// all found files to backup
global map selected_files = nil;	// selected files to backup


/**
 * Return capacity of required medium
 * @param media Medium descriptions
 * @param m Identification of required medium
 * @return integer Size of medium in bytes
 */

global define integer GetCapacity(list media, symbol m) ``{
    integer result = nil;

    if (media != nil)
    {
	foreach(`val, media,
	    ``{
		if (is(val, map) && lookup(val, "symbol", nil) == m)
		{
		    result = lookup(val, "capacity", nil);
		}
	    }
	);
    }

    return result;
}


/**
 * Return backup_search.pl script parameters according to state of variables
 * @return string String with command line parameters
 */

global define string get_search_script_parameters() ``{
    string script_options = " --output-progress";       // required parameter for YaST2 frontend

    if (search)
    {
	script_options = script_options + " --search";

	foreach(`i, dir_list,
	    ``{
		term tmp_id = select(i, 0, nil);

		if (tmp_id != nil)
		{
		    string tmp_d = select(tmp_id, 0, nil);

		    if (tmp_d != nil)
		    {
			script_options = script_options + " --exclude-dir " + tmp_d;
		    }
		}
	    }
	);
	foreach(`i, fs_exclude, ``{script_options = script_options + " --exclude-fs " + i;});
    }

    if (!do_md5_test)
    {
	script_options = script_options + " --no-md5";
    }

    y2debug("Search script options: %1", script_options);

    return script_options;
}


/**
 * Return backup_search.pl script parameters according to state of variables
 * @param file_list Where is list of files to backup stored
 * @param file_comment Where is comment stored
 * @return string String with command line parameters
 */

global define string get_archive_script_parameters(string file_list, string file_comment) ``{
    string archive_options = " --verbose --files-info " + file_list + " --archive-name "
	+ archive_name + " --comment-file " + file_comment;

    if (system)
    {
        // add partition tabel option
	if (backup_pt)
	{
	    archive_options = archive_options + " --store-ptable";
	}

	list tmp_selected_pt = [];
	foreach(`sel_tmp_pt, ext2_backup,	// get device names from `item(`id(XYZ), "XYZ")
	    ``{
		string tmp = select(sel_tmp_pt, 1, nil);

		if (tmp != nil)
		{
		    tmp_selected_pt = add(tmp_selected_pt, tmp);
		}
	    }
	);

	list partitions = (backup_all_ext2) ? detected_ext2 : (backup_none_ext2 ? [] : tmp_selected_pt);

	y2milestone("Backup Ext2 partitions: %1", partitions);

	foreach(`spt, partitions, ``{archive_options = archive_options + " --store-ext2 " + spt;});
    }


    map typemap = $[
	`tgz : "tgz",
	`tbz : "tbz2",
	`tar : "tar",
	`stgz : "stgz",
	`stbz : "stbz2",
	`star : "star",
	`txt : "txt"
    ];

    archive_options = archive_options + " --archive-type " + typemap[archive_type]:"tgz";


    if (multi_volume)
    {
	if (volume_size == `user_defined)
	{
	    // compute volume size (in kiB)
	    integer vol_size = tointeger( ((tofloat(user_volume_size)) * (tofloat(GetCapacity(units_description, user_volume_unit)))) / 1024.0 );

	    y2debug("Volume size is %1 kiB", vol_size);

	    if (vol_size > 0)
	    {
		archive_options = archive_options + " --multi-volume " + sformat("%1", vol_size);
	    }
	    else
	    {
		y2warning("Bad volume size: %1", user_volume_size);
	    }
	}
	else
	{
	    archive_options = archive_options + " --multi-volume " + GetCapacity(media_descriptions, volume_size);
	}
    }

    y2debug("Archive script options: %1", archive_options);

    return archive_options;
}


/**
 * Exclude file systems without device
 */

global define void ExcludeNodevFS() ``{
    map filesystems = SCR::Read(.proc.filesystems);

    if (filesystems == nil)
    {
	return;
    }

    foreach(`k, `v, filesystems, ``{
	    if (v == "nodev")
	    {
		fs_exclude = add(fs_exclude, k);
	    }
	}
    );

    fs_exclude = toset(fs_exclude);
}


/**
 * Write autoinstallation profile to file autoinst.xml to the same directory as archive
 * @return map map $[ "result" : boolean (true on success), "profile" : string (profile file name) ]
 */

global define map WriteProfile(list volumes) ``{

    import "Profile";
    
    string archive = archive_name;
    integer pos = findlastof(archive, "/");
    string dir = "";
    string file = archive;
    boolean store_network = false;

    if (pos != nil && pos > 0)
    {
	dir = substring(archive, 0, pos) + "/";
	file = substring(archive, pos + 1);
    }

    string directory = dir;

    y2debug("dir: %1, file: %2", dir, file);

    // create profile with with currently available resources (partitioning, software etc.)
    AIClone::Process();
  

    string prefix = "file://";

    // change prefix according to volume size or archive destination
    // check if file is written to NFS file system
    list fs = SCR::Read(.proc.mounts);

    fs = filter(map info, fs, ``{return (lookup(info, "vfstype", "") == "nfs");});

    foreach(map info, fs, ``{
	    string mountpoint = lookup(info, "file", "");
	    string spec = lookup(info, "spec", "");

	    string server = substring(spec, 0, findfirstof(spec, ":"));
	    string remdir = substring(spec, findfirstof(spec, ":") + 1);

	    if (mountpoint != "" && spec != "")
	    {
		if (substring(archive, 0, size(mountpoint)) == mountpoint)
		{
		    y2milestone("NFS server: %1, directory: %2", server, remdir);

		    prefix = "nfs://";
		    // archive is located on NFS - store network config to profile
		    store_network = true;
		    dir = server + ":" + remdir + "/";
		}
	    }
	}
    );

    // set prefix according to volume size
    if (prefix == "" && multi_volume == true)
    {
	if (volume_size == `fd144 || volume_size == `fd12)
	{
	    prefix = "fd://";
	    dir = "/";
	}
	else if (volume_size == `cd700 || volume_size == `cd650)
	{
	    prefix = "cd://";
	    dir = "/";
	}
    }

    y2debug("backup write profile: prefix=%1, dir=%2", prefix, dir);

    list volumestrings = [];

    if (size(volumes) > 0)
    {
	foreach(string volfile, volumes, ``{
		string f = volfile;
		integer pos = findlastof(volfile, "/");
		if (pos != nil && pos > 0)
		{
		    f = substring(volfile, pos + 1);
		}

		volumestrings = add(volumestrings, prefix + dir + f);
	    }
	);
    }
    else
    {
	volumestrings = [ prefix + dir + file ];
    }

    map restore = $[ "archives" : volumestrings ];

    // store network configuration if archive will be read from NFS
    if (store_network == true)
    {
	Progress::off();

	Lan::Read();
	map network_config = Lan::Export();

	y2milestone("Storing network config to profile: %1", network_config);
	Profile::Flat["networking"] = network_config;
	Progress::on();
    }

    // add default selection - select all packages to restore
    map packages_sel = $[];

    foreach(string pkg, map info, selected_files, ``{
	    // get package base name
	    if (pkg != "")
	    {
		pkg = regexpsub(pkg, "(.*)-.*-.*", "\\1");
	    }
	    else
	    {
		pkg = "_NoPackage_";
	    }

	    packages_sel[pkg] = $["sel_type" : "X"];
	}
    );

    restore["selection"] = packages_sel;

    Profile::Flat["restore"] = restore;
    


    if (directory == "")
    {
	directory = "/";
    }

    string profilefile = directory + "autoinst.xml";

    return $[ "result" : Profile::Write(profilefile), "profile" : profilefile ];
}

}

