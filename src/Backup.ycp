/**
 *  File:
 *    Backup.ycp
 *
 *  Module:
 *    Backup module
 *
 *  Authors:
 *    Ladislav Slezak <lslezak@suse.cz>
 *
 *  $Id$
 *
 *  Main file for backup module
 *
 */


{

module	"Backup";

import "AutoinstClone";
import "Profile";
import "Lan";
import "Progress";

textdomain "backup";

global string script_store_ext2_area = "/sbin/e2image";
global string script_get_partition_table = "/sbin/fdisk -l";
global string script_get_files = "/usr/lib/YaST2/bin/backup_search.pl";
global string script_create_archive = "/usr/lib/YaST2/bin/backup_archive.pl";

// global settings 

global map backup_profiles = $[] ;		// map of all available profiles

// global defaults
global string default_archive_name = "";		// archive file name
global string default_description = "";			// user comment
global symbol default_archive_type = `tgz;		// archive type

global boolean default_multi_volume = false;
global symbol default_volume_size = `fd144;
global string default_user_volume_size = "";
global symbol default_user_volume_unit = nil;

global boolean default_search = true;			// search files which do not belong to any package
global boolean default_system = false;			// backup system areas
global boolean default_display = false;		// display files before creating archive
global boolean default_do_md5_test = true;

global list default_default_dir = [ "/tmp", "/var/lock", "/var/run", "/var/tmp", "/var/cache" ];		// default excluded directoried from search
global list default_dir_list = nil;			// selected directoried to exclude

global list default_fs_exclude = [ "iso9660" ];			// selected filesystems to exclude from search
global list default_detected_fs = nil;			// detected filesystems

global list default_detected_ext2 = nil;		// detected mounted ext2 filesystems
global list default_ext2_backup = [];			// selected ext2 filesystems to backup

global boolean default_backup_pt = true;		// backup partition table

global boolean default_backup_all_ext2 = false;		// backup all mounted ext2 partitions
global boolean default_backup_none_ext2 = true;		// backup none ext2 partitions
global boolean default_backup_selected_ext2 = false;	// backup selected ext2 partitions


global map default_backup_files = $[ ];		// all found files to backup
global map default_selected_files = nil;	// selected files to backup
global list default_unselected_files = nil;	// files, which user explicitly unselected

// global variables initialized to default values:
global string archive_name = eval( default_archive_name );		// archive file name
global string description = eval( default_description );		// user comment
global symbol archive_type = eval( default_archive_type );		// archive type

global boolean multi_volume = eval( default_multi_volume );
global symbol volume_size = eval( default_volume_size );
global string user_volume_size = eval( default_user_volume_size );
global symbol user_volume_unit = eval( default_user_volume_unit );

global boolean search = eval( default_search );			// search files which do not belong to any package
global boolean system = eval( default_system );			// backup system areas
global boolean display = eval( default_display );		// display files before creating archive
global boolean do_md5_test = eval( default_do_md5_test );

global list default_dir = eval( default_default_dir ); 		// default excluded directoried from search
global list dir_list = eval( default_dir_list );		// selected directoried to exclude

global list fs_exclude = eval( default_fs_exclude );		// selected filesystems to exclude from search
global list detected_fs = eval( default_detected_fs );		// detected filesystems

global list detected_ext2 = eval( default_detected_ext2 );	// detected mounted ext2 filesystems
global list ext2_backup = eval( default_ext2_backup );		// selected ext2 filesystems to backup

global boolean backup_pt = eval( default_backup_pt );		// backup partition table

global boolean backup_all_ext2 = eval( default_backup_all_ext2 );		// backup all mounted ext2 partitions
global boolean backup_none_ext2 = eval( default_backup_none_ext2 );		// backup none ext2 partitions
global boolean backup_selected_ext2 = eval( default_backup_selected_ext2 );	// backup selected ext2 partitions


global map backup_files = eval( default_backup_files );		// all found files to backup
global map selected_files = eval( default_selected_files );	// selected files to backup
global list unselected_files = eval( default_unselected_files );	// files, which user explicitly unselected

global boolean no_interactive = false; 	// whether the user should setup configuration manually
// end of global settings

// media description - capacity is maximum file size which fits
// to formatted medium using widely used file system (FAT on floppies)

global list media_descriptions = [
    $[
	"label" : _("Floppy 1.44 MB"),
	"symbol" : `fd144,
	"capacity" : 1423 // 1457664B is exact size for FAT fs
    ],
    $[
	"label" : _("Floppy 1.2 MB"),
	"symbol" : `fd12,
	"capacity" : 1185 // 1213952B is exact size for FAT fs
    ],
    $[
	"label" : _("ZIP 100 MB"),
	"symbol" : `zip100,
	"capacity" : 95*1024	// exact size is 96MiB (64 heads, 32 sectors, 96 cylinders, 512B sector)
    ],
/*    $[
	"label" : _("ZIP 250 MB"),
	"symbol" : `zip250,
	"capacity" : ?????
    ],*/
    $[
	"label" : _("CD-R/RW 650 MB (74 min.)"),
	"symbol" : `cd650,
	"capacity" : 649*1024	// exact size is 650.4 MB - remaining space is for ISO fs
    ],
    $[
	"label" : _("CD-R/RW 700 MB (80 min.)"),
	"symbol" : `cd700,
	"capacity" : 702*1024	// exact size is 703.1 MB - remaining space is for ISO fs
    ]
];

global list units_description = [
    $[
	"label" : _("bytes"),
	"capacity" : 1,
	"symbol"   : `B
    ],
    $[
	"label" : _("kB"),
	"capacity" : 1000,
	"symbol"   : `kB
    ],
    $[
	"label" : _("kiB"),
	"capacity" : 1024,
	"symbol"   : `kiB
    ],
    $[
	"label" : _("MB"),
	"capacity" : 1000000,
	"symbol"   : `MB
    ],
    $[
	"label" : _("MiB"),
	"capacity" : 1024*1024,
	"symbol"   : `MiB
    ],
];


/**
 * Return capacity of required medium
 * @param media Medium descriptions
 * @param m Identification of required medium
 * @return integer Size of medium in bytes
 */

global define integer GetCapacity(list media, symbol m) ``{
    integer result = nil;

    if (media != nil)
    {
	foreach(`val, media,
	    ``{
		if (is(val, map) && lookup(val, "symbol", nil) == m)
		{
		    result = lookup(val, "capacity", nil);
		}
	    }
	);
    }

    return result;
}


/**
 * Return backup_search.pl script parameters according to state of variables
 * @return string String with command line parameters
 */

global define string get_search_script_parameters() ``{
    string script_options = " --output-progress";       // required parameter for YaST2 frontend

    if (search)
    {
	script_options = script_options + " --search";

	foreach(`i, dir_list,
	    ``{
		term tmp_id = select(i, 0, nil);

		if (tmp_id != nil)
		{
		    string tmp_d = select(tmp_id, 0, nil);

		    if (tmp_d != nil)
		    {
			script_options = script_options + " --exclude-dir " + tmp_d;
		    }
		}
	    }
	);
	foreach(`i, fs_exclude, ``{script_options = script_options + " --exclude-fs " + i;});
    }

    if (!do_md5_test)
    {
	script_options = script_options + " --no-md5";
    }

    y2debug("Search script options: %1", script_options);

    return script_options;
}


/**
 * Return backup_search.pl script parameters according to state of variables
 * @param file_list Where is list of files to backup stored
 * @param file_comment Where is comment stored
 * @return string String with command line parameters
 */

global define string get_archive_script_parameters(string file_list, string file_comment) ``{
    string archive_options = " --verbose --files-info " + file_list + " --archive-name "
	+ archive_name + " --comment-file " + file_comment;

    if (system)
    {
        // add partition tabel option
	if (backup_pt)
	{
	    archive_options = archive_options + " --store-ptable";
	}

	list tmp_selected_pt = [];
	foreach(`sel_tmp_pt, ext2_backup,	// get device names from `item(`id(XYZ), "XYZ")
	    ``{
		string tmp = select(sel_tmp_pt, 1, nil);

		if (tmp != nil)
		{
		    tmp_selected_pt = add(tmp_selected_pt, tmp);
		}
	    }
	);

	list partitions = (backup_all_ext2) ? detected_ext2 : (backup_none_ext2 ? [] : tmp_selected_pt);

	y2milestone("Backup Ext2 partitions: %1", partitions);

	foreach(`spt, partitions, ``{archive_options = archive_options + " --store-ext2 " + spt;});
    }


    map typemap = $[
	`tgz : "tgz",
	`tbz : "tbz2",
	`tar : "tar",
	`stgz : "stgz",
	`stbz : "stbz2",
	`star : "star",
	`txt : "txt"
    ];

    archive_options = archive_options + " --archive-type " + typemap[archive_type]:"tgz";


    if (multi_volume)
    {
	if (volume_size == `user_defined)
	{
	    // compute volume size (in kiB)
	    integer vol_size = tointeger( ((tofloat(user_volume_size)) * (tofloat(GetCapacity(units_description, user_volume_unit)))) / 1024.0 );

	    y2debug("Volume size is %1 kiB", vol_size);

	    if (vol_size > 0)
	    {
		archive_options = archive_options + " --multi-volume " + sformat("%1", vol_size);
	    }
	    else
	    {
		y2warning("Bad volume size: %1", user_volume_size);
	    }
	}
	else
	{
	    archive_options = archive_options + " --multi-volume " + GetCapacity(media_descriptions, volume_size);
	}
    }

    y2debug("Archive script options: %1", archive_options);

    return archive_options;
}


/**
 * Exclude file systems without device
 */

global define void ExcludeNodevFS() ``{
    map filesystems = SCR::Read(.proc.filesystems);

    if (filesystems == nil)
    {
	return;
    }

    foreach(`k, `v, filesystems, ``{
	    if (v == "nodev")
	    {
		fs_exclude = add(fs_exclude, k);
	    }
	}
    );

    fs_exclude = toset(fs_exclude);
}


/**
 * Write autoinstallation profile to file autoinst.xml to the same directory as archive
 * @return map map $[ "result" : boolean (true on success), "profile" : string (profile file name) ]
 */

global define map WriteProfile(list volumes) ``{

    import "Profile";

    string archive = archive_name;
    integer pos = findlastof(archive, "/");
    string dir = "";
    string file = archive;
    boolean store_network = false;

    if (pos != nil && pos > 0)
    {
	dir = substring(archive, 0, pos) + "/";
	file = substring(archive, pos + 1);
    }

    string directory = dir;

    y2debug("dir: %1, file: %2", dir, file);

    // create profile with with currently available resources (partitioning, software etc.)
    AutoinstClone::Process();

    string prefix = "file://";

    // change prefix according to volume size or archive destination
    // check if file is written to NFS file system
    list fs = SCR::Read(.proc.mounts);

    fs = filter(map info, fs, ``{return (lookup(info, "vfstype", "") == "nfs");});

    foreach(map info, fs, ``{
	    string mountpoint = lookup(info, "file", "");
	    string spec = lookup(info, "spec", "");

	    string server = substring(spec, 0, findfirstof(spec, ":"));
	    string remdir = substring(spec, findfirstof(spec, ":") + 1);

	    if (mountpoint != "" && spec != "")
	    {
		if (substring(archive, 0, size(mountpoint)) == mountpoint)
		{
		    y2milestone("NFS server: %1, directory: %2", server, remdir);

		    prefix = "nfs://";
		    // archive is located on NFS - store network config to profile
		    store_network = true;
		    dir = server + ":" + remdir + "/";
		}
	    }
	}
    );

    // set prefix according to volume size
    if (prefix == "" && multi_volume == true)
    {
	if (volume_size == `fd144 || volume_size == `fd12)
	{
	    prefix = "fd://";
	    dir = "/";
	}
	else if (volume_size == `cd700 || volume_size == `cd650)
	{
	    prefix = "cd://";
	    dir = "/";
	}
    }

    y2debug("backup write profile: prefix=%1, dir=%2", prefix, dir);

    list volumestrings = [];

    if (size(volumes) > 0)
    {
	foreach(string volfile, volumes, ``{
		string f = volfile;
		integer pos = findlastof(volfile, "/");
		if (pos != nil && pos > 0)
		{
		    f = substring(volfile, pos + 1);
		}

		volumestrings = add(volumestrings, prefix + dir + f);
	    }
	);
    }
    else
    {
	volumestrings = [ prefix + dir + file ];
    }

    map restore = $[ "archives" : volumestrings ];

    // store network configuration if archive will be read from NFS
    if (store_network == true)
    {
	Progress::off();

	Lan::Read();
	map network_config = Lan::Export();

	y2milestone("Storing network config to profile: %1", network_config);
	Profile::Flat["networking"] = network_config;
	Progress::on();
    }

    // add default selection - select all packages to restore
    map packages_sel = $[];

    foreach(string pkg, map info, selected_files, ``{
	    // get package base name
	    if (pkg != "")
	    {
		pkg = regexpsub(pkg, "(.*)-.*-.*", "\\1");
	    }
	    else
	    {
		pkg = "_NoPackage_";
	    }

	    packages_sel[pkg] = $["sel_type" : "X"];
	}
    );

    restore["selection"] = packages_sel;

    Profile::Flat["restore"] = restore;
    


    if (directory == "")
    {
	directory = "/";
    }

    string profilefile = directory + "autoinst.xml";

    return $[ "result" : Profile::Save(profilefile), "profile" : profilefile ];
}

// Read backup profiles form file, do not set any global settings
global define boolean ReadBackupProfiles() ``{
    backup_profiles = SCR::Read( .target.ycp, "/var/adm/YaST/backup/profiles" );
    
    // if the list is empty or the file does not exists, set empty map
    if( backup_profiles == nil ) backup_profiles = $[];
    
    return ( backup_profiles != $[] ) ;
}

// Write current backup profiles to a file
global define boolean WriteBackupProfiles() ``{
    if( !SCR::Write (.target.ycp, "/var/adm/YaST/backup/profiles", backup_profiles ) )
    {
	y2error( "Unable to write profiles ino a file" );
	return false;
    }
    return true;
}

// Store current settings into a backup profile. If the name of the profile 
// cannot be found, create a new one
global define boolean StoreSettingsToBackupProfile( string profile_name ) ``{
    
    // if there is an old profile, remove it
    if( haskey( backup_profiles, profile_name ) )
    {
	remove( backup_profiles, profile_name );
    }
    
    map new_profile = $[
	`archive_name 		: archive_name, 
	`description  		: description,
	`archive_type 		: archive_type,
	`multi_volume 		: multi_volume,
	`volume_size  		: volume_size,
	`user_volume_size 	: user_volume_size,
	`user_volume_unit 	: user_volume_unit, 
	`search 		: search, 
	`system 		: system, 
	`display 		: display, 
	`do_md5_test 		: do_md5_test, 
	`default_dir		: default_dir, 
	`dir_list		: dir_list, 
	`fs_exclude		: fs_exclude, 
	`detected_fs		: detected_fs,
	`detected_ext2		: detected_ext2, 
	`ext2_backup		: ext2_backup,
	`backup_pt		: backup_pt,
	`backup_all_ext2	: backup_all_ext2, 
	`backup_none_ext2	: backup_none_ext2, 
	`backup_selected_ext2	: backup_selected_ext2, 
	`unselected_files 	: unselected_files
    ] ;
    
    // add the new profile
    backup_profiles = add( backup_profiles, profile_name, new_profile );    
}

// Restore the global settings from a given backup profile. If the name of the
// profile cannot be found, return false, otherwise return true.
global define boolean RestoreSettingsFromBackupProfile( string profile_name ) ``{

    // return false, is there is no such profile
    if( !haskey( backup_profiles, profile_name ) ) return false;
    
    // get the profile data
    map profile = lookup( backup_profiles, profile_name, nil );
    
    // setup global settings according to profile
    // TODO: check, if all settings are valid
    archive_name = lookup( profile, `archive_name, default_archive_name ); 
    description = lookup( profile, `description, default_description);
    archive_type = lookup( profile, `archive_type, default_archive_type);
    multi_volume = lookup( profile, `multi_volume, default_multi_volume );
    volume_size = lookup( profile, `volume_size, default_volume_size );
    user_volume_size = lookup( profile, `user_volume_size, default_user_volume_size);
    user_volume_unit = lookup( profile, `user_volume_unit, default_user_volume_unit );
    search = lookup( profile, `search, default_search );
    system = lookup( profile, `system, default_system );
    display = lookup( profile, `display,  default_display );
    do_md5_test = lookup( profile, `do_md5_test, default_do_md5_test );
    default_dir = lookup( profile, `default_dir, default_default_dir );
    dir_list = lookup( profile, `dir_list, default_dir_list );
    fs_exclude = lookup( profile, `fs_exclude, default_fs_exclude );
    detected_fs = lookup( profile, `detected_fs, default_detected_fs );
    detected_ext2 = lookup( profile, `detected_ext2, default_detected_ext2 ); 
    ext2_backup = lookup( profile, `ext2_backup, default_ext2_backup );
    backup_pt = lookup( profile, `backup_pt, default_backup_pt );
    backup_all_ext2 = lookup( profile, `backup_all_ext2, default_backup_all_ext2 );
    backup_none_ext2 = lookup( profile, `backup_none_ext2, default_backup_none_ext2 );
    backup_selected_ext2 = lookup( profile, `backup_selected_ext2, default_backup_selected_ext2 );
    unselected_files = lookup( profile, `unselected_files, default_unselected_files );
    
    selected_files = default_selected_files;
    backup_files = default_backup_files;
}

// Restore the default global settings.
global define void RestoreDefaultSettings() ``{

    // setup global settings according to defaults
    archive_name = eval( default_archive_name ); 
    description = eval( default_description );
    archive_type = eval( default_archive_type );
    multi_volume = eval( default_multi_volume );
    volume_size = eval( default_volume_size );
    user_volume_size = eval( default_user_volume_size );
    user_volume_unit = eval( default_user_volume_unit );
    search = eval( default_search );
    system = eval( default_system );
    display = eval( default_display );
    do_md5_test = eval( default_do_md5_test );
    default_dir = eval( default_default_dir );
    dir_list = eval( default_dir_list );
    fs_exclude = eval( default_fs_exclude );
    detected_fs = eval( default_detected_fs );
    detected_ext2 = eval( default_detected_ext2 ); 
    ext2_backup = eval( default_ext2_backup );
    backup_pt = eval( default_backup_pt );
    backup_all_ext2 = eval( default_backup_all_ext2 );
    backup_none_ext2 = eval( default_backup_none_ext2 );
    backup_selected_ext2 = eval( default_backup_selected_ext2 );
    unselected_files = eval( default_unselected_files );
    
    selected_files = eval( default_selected_files );
    backup_files = eval( default_backup_files );
}

// helper function to extract the list of currently available profiles
global define list BackupProfileNames() ``{
    list result = maplist( `key, `value, backup_profiles, ``(key) );
    if( result == nil ) return [];
    else return sort( result );
}

// Remove a given profile. Returns false if there is no such profile.
global define boolean RemoveBackupProfile( string profile_name ) ``{
    // return false, is there is no such profile
    if( !haskey( backup_profiles, profile_name ) ) return false;

    backup_profiles = remove( backup_profiles, profile_name );
    
    return true;
}

}

