/**
 *  File:
 *    Backup.ycp
 *
 *  Module:
 *    Backup module
 *
 *  Authors:
 *    Ladislav Slezak <lslezak@suse.cz>
 *
 *  $Id$
 *
 *  Main file for backup module
 *
 */


{

module	"Backup";

import "AutoinstClone";
import "Profile";
import "Progress";

include "backup/functions.ycp";

textdomain "backup";

global string script_store_ext2_area = "/sbin/e2image";
global string script_get_partition_table = "/sbin/fdisk -l";
global string script_get_files = "/usr/lib/YaST2/bin/backup_search.pl";
global string script_create_archive = "/usr/lib/YaST2/bin/backup_archive.pl";

// day names, key is integer used in crontab
global map daynames = $[
    1 : _("Monday"),
    2 : _("Tuesday"),
    3 : _("Wednesday"),
    4 : _("Thursday"),
    5 : _("Friday"),
    6 : _("Saturday"),
    7 : _("Sunday")
];

global map ordinal_numbers = $[
     1 :  _("1st"),
     2 :  _("2nd"),
     3 :  _("3rd"),
     4 :  _("4th"),
     5 :  _("5th"),
     6 :  _("6th"),
     7 :  _("7th"),
     8 :  _("8th"),
     9 :  _("9th"),
    10 : _("10th"),
    11 : _("11th"),
    12 : _("12th"),
    13 : _("13th"),
    14 : _("14th"),
    15 : _("15th"),
    16 : _("16th"),
    17 : _("17th"),
    18 : _("18th"),
    19 : _("19th"),
    20 : _("20th"),
    21 : _("21th"),
    22 : _("22th"),
    23 : _("23th"),
    24 : _("24th"),
    25 : _("25th"),
    26 : _("26th"),
    27 : _("27th"),
    28 : _("28th"),
    29 : _("29th"),
    30 : _("30th"),
    31 : _("31th")
];

// global settings

global map backup_profiles = $[] ;			// map of all available profiles

// global defaults
global string default_archive_name = "";		// archive file name
global string default_description = "";			// user comment
global symbol default_archive_type = `tgz;		// archive type

global boolean default_multi_volume = false;
global symbol default_volume_size = `fd144;
global string default_user_volume_size = "";
global symbol default_user_volume_unit = nil;

global boolean default_search = true;			// search files which do not belong to any package
global boolean default_system = false;			// backup system areas
global boolean default_display = false;			// display files before creating archive
global boolean default_do_md5_test = true;

global list default_default_dir = [ "/tmp", "/var/lock", "/var/run", "/var/tmp", "/var/cache" ];		// default excluded directoried from search
global list default_dir_list = nil;			// selected directoried to exclude

global list default_fs_exclude = [ "iso9660" ];		// selected filesystems to exclude from search
global list default_detected_fs = nil;			// detected filesystems

global list default_detected_ext2 = nil;		// detected mounted ext2 filesystems
global list default_ext2_backup = [];			// selected ext2 filesystems to backup

global boolean default_backup_pt = true;		// backup partition table

global boolean default_backup_all_ext2 = false;		// backup all mounted ext2 partitions
global boolean default_backup_none_ext2 = true;		// backup none ext2 partitions
global boolean default_backup_selected_ext2 = false;	// backup selected ext2 partitions


global map default_backup_files = $[ ];		// all found files to backup
global map default_selected_files = nil;	// selected files to backup
global list default_unselected_files = [ ];	// files, which user explicitly unselected

// global variables initialized to default values:
global string archive_name = eval( default_archive_name );		// archive file name
global string description = eval( default_description );		// user comment
global symbol archive_type = eval( default_archive_type );		// archive type

global boolean multi_volume = eval( default_multi_volume );
global symbol volume_size = eval( default_volume_size );
global string user_volume_size = eval( default_user_volume_size );
global symbol user_volume_unit = eval( default_user_volume_unit );

global boolean search = eval( default_search );			// search files which do not belong to any package
global boolean system = eval( default_system );			// backup system areas
global boolean display = eval( default_display );		// display files before creating archive
global boolean do_md5_test = eval( default_do_md5_test );

global list default_dir = eval( default_default_dir ); 		// default excluded directoried from search
global list dir_list = eval( default_dir_list );		// selected directoried to exclude

global list fs_exclude = eval( default_fs_exclude );		// selected filesystems to exclude from search
global list detected_fs = eval( default_detected_fs );		// detected filesystems

global list detected_ext2 = eval( default_detected_ext2 );	// detected mounted ext2 filesystems
global list ext2_backup = eval( default_ext2_backup );		// selected ext2 filesystems to backup

global boolean backup_pt = eval( default_backup_pt );		// backup partition table

global boolean backup_all_ext2 = eval( default_backup_all_ext2 );		// backup all mounted ext2 partitions
global boolean backup_none_ext2 = eval( default_backup_none_ext2 );		// backup none ext2 partitions
global boolean backup_selected_ext2 = eval( default_backup_selected_ext2 );	// backup selected ext2 partitions


global map backup_files = eval( default_backup_files );		// all found files to backup
global map selected_files = eval( default_selected_files );	// selected files to backup
global list unselected_files = eval( default_unselected_files );	// files, which user explicitly unselected

global boolean no_interactive = false; 	// whether the user should setup configuration manually
global string selected_profile = nil;   // name of the selected profile, nil for no selected profile (default settings)
// end of global settings

// media description - capacity is maximum file size which fits
// to formatted medium using widely used file system (FAT on floppies)

global list media_descriptions = [
    $[
	"label" : _("Floppy 1.44 MB"),
	"symbol" : `fd144,
	"capacity" : 1423 // 1457664B is exact size for FAT fs
    ],
    $[
	"label" : _("Floppy 1.2 MB"),
	"symbol" : `fd12,
	"capacity" : 1185 // 1213952B is exact size for FAT fs
    ],
    $[
	"label" : _("ZIP 100 MB"),
	"symbol" : `zip100,
	"capacity" : 95*1024	// exact size is 96MiB (64 heads, 32 sectors, 96 cylinders, 512B sector)
    ],
/*    $[
	"label" : _("ZIP 250 MB"),
	"symbol" : `zip250,
	"capacity" : ?????
    ],*/
    $[
	"label" : _("CD-R/RW 650 MB (74 min.)"),
	"symbol" : `cd650,
	"capacity" : 649*1024	// exact size is 650.4 MB - remaining space is for ISO fs
    ],
    $[
	"label" : _("CD-R/RW 700 MB (80 min.)"),
	"symbol" : `cd700,
	"capacity" : 702*1024	// exact size is 703.1 MB - remaining space is for ISO fs
    ]
];

global list units_description = [
    $[
	"label" : _("bytes"),
	"capacity" : 1,
	"symbol"   : `B
    ],
    $[
	// 10^3 bytes
	"label" : _("kB"),
	"capacity" : 1000,
	"symbol"   : `kB
    ],
    $[
	// 2^10 bytes
	"label" : _("kiB"),
	"capacity" : 1024,
	"symbol"   : `kiB
    ],
    $[
	// 10^6 bytes
	"label" : _("MB"),
	"capacity" : 1000000,
	"symbol"   : `MB
    ],
    $[
	// 2^20 bytes
	"label" : _("MiB"),
	"capacity" : 1024*1024,
	"symbol"   : `MiB
    ],
];


/**
 * Return capacity of required medium
 * @param media Medium descriptions
 * @param m Identification of required medium
 * @return integer Size of medium in bytes
 */

global define integer GetCapacity(list media, symbol m) ``{
    integer result = nil;

    if (media != nil)
    {
	foreach(`val, media,
	    ``{
		if (is(val, map) && lookup(val, "symbol", nil) == m)
		{
		    result = lookup(val, "capacity", nil);
		}
	    }
	);
    }

    return result;
}


/**
 * Return backup_search.pl script parameters according to state of variables
 * @return string String with command line parameters
 */

global define string get_search_script_parameters() ``{
    string script_options = " --output-progress";       // required parameter for YaST2 frontend

    if (search)
    {
	script_options = script_options + " --search";

	foreach(`i, dir_list,
	    ``{
		term tmp_id = select(i, 0, nil);

		if (tmp_id != nil)
		{
		    string tmp_d = select(tmp_id, 0, nil);

		    if (tmp_d != nil)
		    {
			script_options = script_options + " --exclude-dir " + tmp_d;
		    }
		}
	    }
	);
	foreach(`i, fs_exclude, ``{script_options = script_options + " --exclude-fs " + i;});
    }

    if (!do_md5_test)
    {
	script_options = script_options + " --no-md5";
    }

    script_options = script_options + " --widget-file " + SCR::Read(.target.tmpdir) + "/items.ycp";

    y2debug("Search script options: %1", script_options);

    return script_options;
}


/**
 * Return backup_search.pl script parameters according to state of variables
 * @param file_list Where is list of files to backup stored
 * @param file_comment Where is comment stored
 * @return string String with command line parameters
 */

global define string get_archive_script_parameters(string file_list, string file_comment) ``{
    string archive_options = " --verbose --files-info " + file_list + " --archive-name "
	+ archive_name + " --comment-file " + file_comment;

    if (system)
    {
        // add partition tabel option
	if (backup_pt)
	{
	    archive_options = archive_options + " --store-ptable";
	}

	list tmp_selected_pt = [];
	foreach(`sel_tmp_pt, ext2_backup,	// get device names from `item(`id(XYZ), "XYZ")
	    ``{
		string tmp = select(sel_tmp_pt, 1, nil);

		if (tmp != nil)
		{
		    tmp_selected_pt = add(tmp_selected_pt, tmp);
		}
	    }
	);

	list partitions = (backup_all_ext2) ? detected_ext2 : (backup_none_ext2 ? [] : tmp_selected_pt);

	y2milestone("Backup Ext2 partitions: %1", partitions);

	foreach(`spt, partitions, ``{archive_options = archive_options + " --store-ext2 " + spt;});
    }


    map typemap = $[
	`tgz : "tgz",
	`tbz : "tbz2",
	`tar : "tar",
	`stgz : "stgz",
	`stbz : "stbz2",
	`star : "star",
	`txt : "txt"
    ];

    archive_options = archive_options + " --archive-type " + typemap[archive_type]:"tgz";


    if (multi_volume)
    {
	if (volume_size == `user_defined)
	{
	    // compute volume size (in kiB)
	    integer vol_size = tointeger( ((tofloat(user_volume_size)) * (tofloat(GetCapacity(units_description, user_volume_unit)))) / 1024.0 );

	    y2debug("Volume size is %1 kiB", vol_size);

	    if (vol_size > 0)
	    {
		archive_options = archive_options + " --multi-volume " + sformat("%1", vol_size);
	    }
	    else
	    {
		y2warning("Bad volume size: %1", user_volume_size);
	    }
	}
	else
	{
	    archive_options = archive_options + " --multi-volume " + GetCapacity(media_descriptions, volume_size);
	}
    }

    y2debug("Archive script options: %1", archive_options);

    return archive_options;
}


/**
 * Exclude file systems without device
 */

global define void ExcludeNodevFS() ``{
    map filesystems = SCR::Read(.proc.filesystems);

    if (filesystems == nil)
    {
	return;
    }

    foreach(`k, `v, filesystems, ``{
	    if (v == "nodev")
	    {
		fs_exclude = add(fs_exclude, k);
	    }
	}
    );

    fs_exclude = toset(fs_exclude);
}


/**
 * Write autoinstallation profile to file autoinst.xml to the same directory as archive
 * @param volumes list of created archives (it is written to the XML profile as restoration source)
 * @return map map $[ "result" : boolean (true on success), "profile" : string (profile file name) ]
 */

global define map WriteProfile(list volumes) ``{

    import "Profile";

    string archive = archive_name;
    integer pos = findlastof(archive, "/");
    string dir = "";
    string file = archive;

    if (pos != nil && pos > 0)
    {
	dir = substring(archive, 0, pos) + "/";
	file = substring(archive, pos + 1);
    }

    string directory = dir;

    y2debug("dir: %1, file: %2", dir, file);

    string prefix = "file://";

    // change prefix according to volume size or archive destination
    // check if file is written to NFS file system
    list fs = SCR::Read(.proc.mounts);

    fs = filter(map info, fs, ``{return (lookup(info, "vfstype", "") == "nfs");});

    foreach(map info, fs, ``{
	    string mountpoint = lookup(info, "file", "");
	    string spec = lookup(info, "spec", "");

	    string server = substring(spec, 0, findfirstof(spec, ":"));
	    string remdir = substring(spec, findfirstof(spec, ":") + 1);

	    if (mountpoint != "" && spec != "")
	    {
		if (substring(archive, 0, size(mountpoint)) == mountpoint)
		{
		    y2milestone("NFS server: %1, directory: %2", server, remdir);

		    prefix = "nfs://";
		    dir = server + ":" + remdir + "/";
		}
	    }
	}
    );

    // set prefix according to volume size
    if (prefix == "" && multi_volume == true)
    {
	if (volume_size == `fd144 || volume_size == `fd12)
	{
	    prefix = "fd://";
	    dir = "/";
	}
	else if (volume_size == `cd700 || volume_size == `cd650)
	{
	    prefix = "cd://";
	    dir = "/";
	}
    }

    y2debug("backup write profile: prefix=%1, dir=%2", prefix, dir);

    list volumestrings = [];

    if (size(volumes) > 0)
    {
	foreach(string volfile, volumes, ``{
		string f = volfile;
		integer pos = findlastof(volfile, "/");
		if (pos != nil && pos > 0)
		{
		    f = substring(volfile, pos + 1);
		}

		volumestrings = add(volumestrings, prefix + dir + f);
	    }
	);
    }
    else
    {
	volumestrings = [ prefix + dir + file ];
    }

    map restore = $[ "archives" : volumestrings ];

    // store network configuration - required if archive will be read from NFS
    AutoinstClone::additional = ["lan"];

    // create profile with with currently available resources (partitioning, software etc.)
    y2milestone("Clonning system started...");
    AutoinstClone::Process();
    y2milestone("System clonned");

    // add default selection - select all packages to restore
    map packages_sel = $[];

    foreach(string pkg, map info, selected_files, ``{
	    // get package base name
	    if (pkg != "")
	    {
		pkg = regexpsub(pkg, "(.*)-.*-.*", "\\1");
	    }
	    else
	    {
		pkg = "_NoPackage_";
	    }

	    packages_sel[pkg] = $["sel_type" : "X"];
	}
    );

    restore["selection"] = packages_sel;

    Profile::Flat["restore"] = restore;

    if (directory == "")
    {
	directory = "/";
    }

    string profilefile = directory + GetBaseName(archive_name) + ".xml";

    return $[ "result" : Profile::Save(profilefile), "profile" : profilefile ];
}


/**
 * Parse cron file
 * @param filename File to parse
 * @return map parsed values: $["auto":boolean, "day":integer, "hour":integer,
 *         "minute":integer, "weekday":integer, "every":symbol] or empty map if
 *         parse error occured
 */

global define map ReadCronSetting(string filename) ``{
    map ret = $[];

    if (filename == nil || filename == "")
    {
	return ret;
    }

    string filecontent = SCR::Read(.target.string, filename);
    list lines = splitstring(filecontent, "\n");

    string line = lines[0]:"";

    if (line == nil || line == "")
    {
	return ret;
    }

    string regex = "^([0-9]*)[ \t]*([0-9]*)[ \t]([^ \t]*)[ \t]([^ \t]*)[ \t]([^ \t]*)[ \t]*[^ \t]*[ \t]*/usr/lib/YaST2/bin/backup_cron[ \t]*\"*([^\"]*)\"*";
    symbol every = `none;
    map cronsettings = $[];
    string profilename = "";

    if (regexpmatch(line, regex))
    {
	integer minute = tointeger(regexpsub(line, regex, "\\1"));
	integer hour = tointeger(regexpsub(line, regex, "\\2"));

	string day = regexpsub(line, regex, "\\3");
	string month = regexpsub(line, regex, "\\4");
	string weekday = regexpsub(line, regex, "\\5");

	y2milestone("hour: %1", regexpsub(line, regex, "\\1"));
	y2milestone("line: %1", line);
	y2milestone("day: %1", day);

	integer intday = 1;
	integer intweekday = 0;

	profilename = regexpsub(line, regex, "\\6");
	y2milestone("profilename: %1", profilename);


	if (month != "*")
	{
	    // error
	}

	if (day == "*" && weekday == "*")
	{
	    // start every day
	    every = `day;
	}
	else if (day == "*")
	{
	    every = `week;
	    intweekday = tointeger(weekday);
	}
	else if (weekday == "*")
	{
	    every = `month;
	    intday = tointeger(day);
	}

	cronsettings = $["auto":true, "day":intday, "hour":hour, "minute":minute, "weekday":intweekday, "every":every];
	y2milestone("cronsettings: %1", cronsettings);
    }

    return (every != `none) ? $["profilename":profilename, "cronsettings": cronsettings] : $[];
}


/**
 * Parse all /etc/cron.d/yast2-backup-* files and update profiles
 */

global define void ReadCronSettings() ``{
    string crondir = "/etc/cron.d";
    list files = SCR::Read(.target.dir, crondir);

    if (size(files) > 0)
    {
	// parse all /etc/cron.d/yast2-backup-* files
	foreach(string file, files, ``{
		if (regexpmatch(file, "yast2-backup-[0-9]*") == true)
		{
		    // parse cron file
		    map cron = ReadCronSetting(crondir + "/" + file);

		    if (cron != $[] && cron != nil)
		    {
			string profilename = cron["profilename"]:"";
			map cronsettings = eval(cron["cronsettings"]:$[]);

			// update profile
			if (profilename != "" && cronsettings != $[])
			{
			    map profile = eval(backup_profiles[profilename]:$[]);

			    // merge maps - include old backup settings from read profile
			    cronsettings = union(eval(profile[`cron_settings]:$[]), cronsettings);

			    profile[`cron_settings] = cronsettings;
			    backup_profiles[profilename] = eval(profile);
			}
		    }
		}
	    }
	);
    }
}


/**
 * Read backup profiles from file, do not set any global settings, just
 * @see backup_profiles. The profiles are stored in hardcoded place (/var/adm/YaST/backup/profiles).
 * @return boolean true if there are some profiles available
 */

global define boolean ReadBackupProfiles() ``{
    backup_profiles = SCR::Read( .target.ycp, "/var/adm/YaST/backup/profiles" );

    // if the list is empty or the file does not exists, set empty map
    if( backup_profiles == nil ) backup_profiles = $[];

    foreach(string profname, map opts, backup_profiles, ``{
	    y2debug("Read profile %1: %2", profname, opts);
	    if (opts[`cron_settings, "auto"]:false == true)
	    {
		y2debug("Deactivating profile %1", profname);
		opts[`cron_settings, "auto"] = false;
		backup_profiles[profname] = eval(opts);
	    }
	}
    );

    ReadCronSettings();

    return ( backup_profiles != $[] ) ;
}


/**
 * Write cron settings from profiles to /etc/cron.d/yast2-backup-* files
 */

global define void WriteCronSettings() ``{
    // remove all old cron files
    SCR::Execute(.target.bash, "/bin/rm -f /etc/cron.d/yast2-backup-*");

    integer idx = 0;
    // create new cron files
    foreach(string name, map opts, backup_profiles, ``{
	    // cron file content
	    string setting = CreateCronSetting(name);

	    if (setting != "" && setting != nil)
	    {
		SCR::Write(.target.string, sformat("/etc/cron.d/yast2-backup-%1", idx), setting);
		y2milestone("Created file: /etc/cron.d/yast2-backup-%1", idx);
		idx = idx + 1;
	    }
	}
    );
}


/**
 * Write the backup profiles to a file - hardcoded /var/adm/YaST/backup/profiles.
 * @return boolean true if the write operation was successful.
 */

global define boolean WriteBackupProfiles() ``{
    if( !SCR::Write (.target.ycp, "/var/adm/YaST/backup/profiles", backup_profiles ) )
    {
	y2error( "Unable to write profiles into a file" );
	UI::ErrorPopup( _("Could not store profiles to disk.
The profile changes will be lost.") );
	return false;
    }

    // update cron setting
    WriteCronSettings();

    return true;
}


/**
 * Take the current profile information and store it into a given profile.
 * If the profile already exists, it will be overwritten.
 * @param profile_name name of a profile to be stored into
 */

global define void StoreSettingsToBackupProfile( string profile_name ) ``{
    
    map new_profile = $[
	`archive_name 		: archive_name, 
	`description  		: description,
	`archive_type 		: archive_type,
	`multi_volume 		: multi_volume,
	`volume_size  		: volume_size,
	`user_volume_size 	: user_volume_size,
	`user_volume_unit 	: user_volume_unit, 
	`search 		: search, 
	`system 		: system, 
	`display 		: display, 
	`do_md5_test 		: do_md5_test, 
	`default_dir		: default_dir, 
	`dir_list		: dir_list, 
	`fs_exclude		: fs_exclude, 
	`detected_fs		: detected_fs,
	`detected_ext2		: detected_ext2, 
	`ext2_backup		: ext2_backup,
	`backup_pt		: backup_pt,
	`backup_all_ext2	: backup_all_ext2, 
	`backup_none_ext2	: backup_none_ext2, 
	`backup_selected_ext2	: backup_selected_ext2, 
	`unselected_files 	: unselected_files
    ] ;
    
    // add the new profile
    backup_profiles = add( backup_profiles, profile_name, new_profile );    
}

/**
 * Restore the global settings from a given backup profile. 
 * @param profile_name name of a profile to be used
 * @return If the name of the profile cannot be found, return false, otherwise return true.
 */
global define boolean RestoreSettingsFromBackupProfile( string profile_name ) ``{

    // return false, is there is no such profile
    if( !haskey( backup_profiles, profile_name ) ) return false;
    
    // get the profile data
    map profile = backup_profiles[profile_name]:nil;

    // setup global settings according to profile
    // TODO: check, if all settings are valid
    archive_name =	profile[ `archive_name ]:	default_archive_name;
    description =	profile[ `description ]:	default_description;
    archive_type =	profile[ `archive_type ]:	default_archive_type;
    multi_volume =	profile[ `multi_volume ]:	default_multi_volume;
    volume_size =	profile[ `volume_size ]:	default_volume_size;
    user_volume_size =  profile[ `user_volume_size ]:	default_user_volume_size;
    user_volume_unit =	profile[ `user_volume_unit ]:	default_user_volume_unit;
    search =		profile[ `search ]:		default_search;
    system =		profile[ `system ]:		default_system;
    display =		profile[ `display ]:		default_display;
    do_md5_test =	profile[ `do_md5_test ]:	default_do_md5_test;
    default_dir =	profile[ `default_dir ]:	default_default_dir;
    dir_list =		profile[ `dir_list ]:		default_dir_list;
    fs_exclude =	profile[ `fs_exclude ]:		default_fs_exclude;
    detected_fs =	profile[ `detected_fs ]:	default_detected_fs;
    detected_ext2 =	profile[ `detected_ext2 ]:	default_detected_ext2;
    ext2_backup =	profile[ `ext2_backup ]:	default_ext2_backup;
    backup_pt =		profile[ `backup_pt ]:		default_backup_pt;
    backup_all_ext2 =	profile[ `backup_all_ext2 ]:	default_backup_all_ext2;
    backup_none_ext2 =	profile[ `backup_none_ext2 ]:	default_backup_none_ext2;
    backup_selected_ext2 =	profile[ `backup_selected_ext2 ]:	default_backup_selected_ext2;
    unselected_files =	profile[ `unselected_files ]:	default_unselected_files;

    selected_files = default_selected_files;
    backup_files = default_backup_files;

    selected_profile = profile_name;

    return true;
}

/**
 * Restore the default global settings.
 */
global define void RestoreDefaultSettings() ``{

    // setup global settings according to defaults
    archive_name = eval( default_archive_name ); 
    description = eval( default_description );
    archive_type = eval( default_archive_type );
    multi_volume = eval( default_multi_volume );
    volume_size = eval( default_volume_size );
    user_volume_size = eval( default_user_volume_size );
    user_volume_unit = eval( default_user_volume_unit );
    search = eval( default_search );
    system = eval( default_system );
    display = eval( default_display );
    do_md5_test = eval( default_do_md5_test );
    default_dir = eval( default_default_dir );
    dir_list = eval( default_dir_list );
    fs_exclude = eval( default_fs_exclude );
    detected_fs = eval( default_detected_fs );
    detected_ext2 = eval( default_detected_ext2 ); 
    ext2_backup = eval( default_ext2_backup );
    backup_pt = eval( default_backup_pt );
    backup_all_ext2 = eval( default_backup_all_ext2 );
    backup_none_ext2 = eval( default_backup_none_ext2 );
    backup_selected_ext2 = eval( default_backup_selected_ext2 );
    unselected_files = eval( default_unselected_files );
    
    selected_files = eval( default_selected_files );
    backup_files = eval( default_backup_files );
    
    selected_profile = nil;
}

/**
 * Get a sorted list of profile names currently available.
 * @return the list of strings (possibly empty).
 */
global define list BackupProfileNames() ``{
    list result = maplist( `key, `value, backup_profiles, ``(key) );
    if( result == nil ) return [];
    else return sort( result );
}

/**
 * Helper function to extract the list of currently available profiles
 * @return list List of item used in the table widget
 */
global define list BackupProfileDescriptions() ``{
    list result = maplist( string key, map value, backup_profiles,
        ``{
	    // description can be multiline - merge lines
	    string descr = mergestring(splitstring(value[`description]:default_description, "\n"), " ");
	    map displayinfo = UI::GetDisplayInfo();
	    // limit size of description shown in the table
	    // maximum length half of width in ncurses UI
	    integer maxsize = (displayinfo["TextMode"]:false) ? (displayinfo["Width"]:80 / 2) : 40;

	    if (size(descr) > maxsize)
	    {
		// use only the beginning of the description, add dots
		descr = substring(descr, 0, maxsize) + "...";
	    }

	    return `item( `id( key ), key, descr, CreateCronDescription(key) );
	}
    );

    if( result == nil ) return [];
    else return result;
}

/**
 * Remove given profile.
 * @param profile_name name of a profile to be removed
 * @return If the name of the profile cannot be found, return false, otherwise return true.
 */
global define boolean RemoveBackupProfile( string profile_name ) ``{
    // return false, is there is no such profile
    if( !haskey( backup_profiles, profile_name ) ) return false;

    backup_profiles = remove( backup_profiles, profile_name );

    return true;
}


/**
 * Create cron file content for selected profile.
 * @param profilename Name of the profile
 * @return string Cron content or empty string if profile has
 *         disabled automatic start
 */

global define string CreateCronSetting(string profilename) ``{
    map input = backup_profiles[profilename, `cron_settings]:$[];
    string ret = "";

    if (input == nil || input == $[])
    {
	return ret;
    }

    if (input["auto"]:false == true)
    {
	integer hour = input["hour"]:0;
	integer minute = input["minute"]:0;
	integer day = input["day"]:1;
	integer weekday = input["weekday"]:0;
	symbol every = input["every"]:`unknown;

	if (every == `day)
	{
	    ret = sformat("%1 %2 * * *  root  /usr/lib/YaST2/bin/backup_cron \"%3\"\n", minute, hour, profilename);
	}
	else if (every == `week)
	{
	    ret = sformat("%1 %2 * * %3  root  /usr/lib/YaST2/bin/backup_cron \"%4\"\n", minute, hour, weekday, profilename);
	}
	else if (every == `month)
	{
	    ret = sformat("%1 %2 %3 * *  root  /usr/lib/YaST2/bin/backup_cron \"%4\"\n", minute, hour, day, profilename);
	}
    }

    return ret;
}


/**
 * Create description of automatic backup.
 * @param profilename Name of the profile
 * @return string description string or empty string if profile has
 *         disabled automatic start
 */

global define string CreateCronDescription(string profilename) ``{
    map input = backup_profiles[profilename, `cron_settings]:$[];
    string ret = "";

    if (input == nil || input == $[])
    {
	return ret;
    }

    if (input["auto"]:false == true)
    {
	integer hour = input["hour"]:0;
	integer minute = input["minute"]:0;
	integer day = input["day"]:1;
	integer weekday = input["weekday"]:0;
	symbol every = input["every"]:`unknown;

	if (every == `day)
	{
	    ret = sformat(_("Backup daily (at %1:%2)"), hour, minute);
	}
	else if (every == `week)
	{
	    ret = sformat(_("Backup weekly (%1 at %2:%3)"), daynames[weekday]:"?", hour, minute);
	}
	else if (every == `month)
	{
	    ret = sformat(_("Backup monthly (%1 day at %2:%3)"), ordinal_numbers[day]:"?", hour, minute);
	}
    }

    return ret;
}

}

